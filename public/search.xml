<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[定时任务组件FluentScheduler]]></title>
    <url>%2F2017%2F12%2F19%2F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BB%84%E4%BB%B6FluentScheduler%2F</url>
    <content type="text"><![CDATA[定时任务组件FluentScheduler的基础使用方法 动态修改任务调用的间隔时间 FluentScheduler Github地址一般常用的方法，在它的github上面就可以找到api，这篇文章的demo主要实现的功能是通过修改appconfig文件内的配置信息，达到修改正在运行的任务时间，当然也可以增加自己的配置代码，如启动，暂停等等。 有一处要注意，修改appconfig文件后，读取时必须调用ConfigurationManager.RefreshSection(“appSettings”);否则会出现读取的值是缓存的情况，导致出错。 AppConfig文件如下12345678910111213&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" /&gt; &lt;/startup&gt; &lt;appSettings&gt; &lt;add key="ChangeStatus" value="1"/&gt; &lt;!--修改状态--&gt; &lt;add key="Interval" value="5"/&gt; &lt;!--间隔值--&gt; &lt;add key="IntervalType" value="Seconds"/&gt; &lt;!--间隔类型年、月、日、时、分、秒--&gt; &lt;add key="HoursOfDay" value="23"/&gt; &lt;!--间隔类型是天时的小时 取值0-23--&gt; &lt;add key="MinutesOfDay" value="59"/&gt; &lt;!--间隔类型是天时的分钟 取值0-59--&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 控制台应用程序源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System;using FluentScheduler;using System.Configuration;namespace FluentSchedulerDemo&#123; class Program &#123; static void Main(string[] args) &#123; //首次允许业务逻辑 JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(1).Seconds(); &#125;); //允许检查 JobManager.AddJob(CheckSchedule, t =&gt; &#123; t.WithName("CheckSchedule").ToRunEvery(10).Seconds(); &#125;); Console.ReadLine(); &#125; /// &lt;summary&gt; /// 定时检查配置文件，动态修改当前工作安排 /// &lt;/summary&gt; static void CheckSchedule() &#123; #region 读取appconfig配置文件 ConfigurationManager.RefreshSection("appSettings");//非常重要！！！刷新后才能读取到更改后的配置信息 int changeStatus = Convert.ToInt32(ConfigurationManager.AppSettings["ChangeStatus"]); int interval = Convert.ToInt32(ConfigurationManager.AppSettings["Interval"]); int hoursOfDay = Convert.ToInt32(ConfigurationManager.AppSettings["HoursOfDay"]); int minutesOfDay = Convert.ToInt32(ConfigurationManager.AppSettings["MinutesOfDay"]); string intervalType = ConfigurationManager.AppSettings["IntervalType"]; #endregion if (changeStatus == 1) &#123; //修改业务逻辑定时任务 JobManager.RemoveJob("ServiceLogic"); Console.WriteLine("CheckSchedule：" + DateTime.Now); #region 根据间隔的类型，修改任务计划时间 switch (intervalType) &#123; case "Seconds": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Seconds(); &#125;); break; case "Minutes": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Minutes(); &#125;); break; case "Hours": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Hours(); &#125;); break; case "Days": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Days().At(hoursOfDay, minutesOfDay); &#125;); break; case "Months": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Months(); &#125;); break; case "Years": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Years(); &#125;); break; &#125; #endregion //更新修改状态 Configuration configuration = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); configuration.AppSettings.Settings["ChangeStatus"].Value = "0"; configuration.Save(); &#125; &#125; /// &lt;summary&gt; /// 业务逻辑 /// &lt;/summary&gt; static void ServiceLogic() &#123; Console.WriteLine("ServiceLogic：" + DateTime.Now); //TODO: 实际的业务逻辑 &#125; &#125;&#125; 程序运行截图 总的来说一句话：使用两个任务计划，一个用来检查配置文件的状态，随时进行更改另一个业务任务计划的运行状态。]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除微信昵称中emoji字符]]></title>
    <url>%2F2017%2F12%2F18%2F%E5%8E%BB%E9%99%A4%E5%BE%AE%E4%BF%A1%E6%98%B5%E7%A7%B0%E4%B8%ADemoji%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[问题描述1、微信公众号获得用户基础信息时，用户的昵称nickname中可能包含emoji表情，而该表情在保存数据库之后在前台页面中使用（导出excel）会导致异常，因此需要该emoji表情去掉。解决方法：替换所有表情字符。 参考地址 1234567891011class Program &#123; static void Main(string[] args) &#123; string nickName = &quot;特殊字符串&quot;; nickName = Regex.Replace(nickName, @&quot;\p&#123;Cs&#125;&quot;, &quot;*&quot;); Console.WriteLine(nickName); Console.ReadKey(); &#125; &#125;]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信公众号-发送文本消息]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E5%8F%91%E9%80%81%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[使用微信公众号，发送文本消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void SendNews(List&lt;dt_Mem&gt; memList,string appID,string appSecret,string message) &#123; openIDList = memList.Select(i =&gt; i.Fields[&quot;openid&quot;].Value).ToList&lt;string&gt;(); var result = SendNews(appID, appSecret, message, openIDList); &#125; /// &lt;summary&gt; ///公众号发送文本信息 /// &lt;/summary&gt; /// &lt;param name=&quot;appID&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;appSecret&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;openIDList&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string SendMessage(string appID, string appSecret, string message, List&lt;string&gt; openIDList) &#123; if (openIDList.Count == 1) &#123; openIDList.Add(&quot; &quot;); &#125; string requestURL = &quot;https://api.weixin.qq.com/cgi-bin/message/mass/send?access_token=&#123;0&#125;&quot;; string openIDString = string.Join(&quot;,&quot;, openIDList.Select(i =&gt; &quot;\&quot;&quot; + i + &quot;\&quot;&quot;)); string temp = &quot;&#123;\&quot;touser\&quot;: [&quot; + openIDString + &quot;],&quot; + &quot;\&quot;msgtype\&quot;: \&quot;text\&quot;, &quot; + &quot;\&quot;text\&quot;: &#123;\&quot;content\&quot;:\&quot;&quot; + message + &quot;\&quot;&#125; &quot; + &quot;&#125;&quot;; //预览接口开发用 string urlName = &quot;您好，这里是为您推荐的链接地址&quot; + message.Substring(message.LastIndexOf(&quot;/&quot;) + 1); message = &quot;&lt;a href=&apos;&quot; + message + &quot;&apos;&gt;&quot; + urlName + &quot;&lt;/a&gt;&quot;; requestURL = &quot; https://api.weixin.qq.com/cgi-bin/message/mass/preview?access_token=&#123;0&#125;&quot;; temp = &quot;&#123;\&quot;touser\&quot;: \&quot;oEWyxv6y7JEuHISt50hQCjrLGHrk\&quot;,&quot; + &quot;\&quot;msgtype\&quot;: \&quot;text\&quot;, &quot; + &quot;\&quot;text\&quot;: &#123;\&quot;content\&quot;:\&quot;&quot; + message + &quot;\&quot;&#125; &quot; + &quot;&#125;&quot;; string strJson = HttpRequestUtil.RequestUrl(string.Format(requestURL, GetAccess_token(appID, appSecret)), &quot;POST&quot;, temp); return strJson; &#125; /// &lt;summary&gt; /// 获得基础接口的access_token /// &lt;/summary&gt; /// &lt;param name=&quot;appID&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;appSecret&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetAccess_token(string appID, string appSecret) &#123; string access_token = &quot;&quot;; CacheManage cache = CacheManage.Instance; if (cache.Contains(&quot;access_token&quot; + appID)) &#123; access_token = cache.Get(&quot;access_token&quot; + appID) as string; &#125; else &#123; string strJson = &quot;&quot;; string requestURL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;0&#125;&amp;secret=&#123;1&#125;&quot;; strJson = HttpRequestUtil.RequestUrl(string.Format(requestURL, appID, appSecret)); access_token = Tools.GetJsonValue(strJson, &quot;access_token&quot;); double cacheMinutes = (double)(Convert.ToInt32(Tools.GetJsonValue(strJson, &quot;expires_in&quot;)) / 60);//将秒转换为分钟 cache.Set(&quot;access_token&quot; + appID, access_token, cacheMinutes); &#125; return access_token; &#125;]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>发送消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.NET防止SQL注入]]></title>
    <url>%2F2017%2F12%2F05%2FNET%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[问题描述：测试人员通过IBM appscan工具进行网站系统扫描，发现SQL注入漏洞，如何能进行全局性的修改，将所有请求的内容进行过滤？ 解决办法：通过全局应用程序类，将所有的请求进行敏感字过滤。 1、Global.asax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using MxWeiXinPF.Common;using System;namespace MxWeiXinPF.Web&#123; public class Global : System.Web.HttpApplication &#123; protected void Application_Start(object sender, EventArgs e) &#123; &#125; protected void Session_Start(object sender, EventArgs e) &#123; &#125; protected void Application_BeginRequest(object sender, EventArgs e) &#123; if (Request.Cookies != null) &#123; if (SafeHelper.CookieData()) &#123; Response.Write(&quot;您提交的Cookie数据有恶意字符！&quot;); Response.End(); &#125; &#125; if (Request.UrlReferrer != null) &#123; if (SafeHelper.referer()) &#123; Response.Write(&quot;您提交的Referrer数据有恶意字符！&quot;); Response.End(); &#125; &#125; if (Request.RequestType.ToUpper() == &quot;POST&quot;) &#123; if (SafeHelper.PostData()) &#123; Response.Write(&quot;您提交的Post数据有恶意字符！&quot;); Response.End(); &#125; &#125; if (Request.RequestType.ToUpper() == &quot;GET&quot;) &#123; if (SafeHelper.GetData()) &#123; Response.Write(&quot;您提交的Get数据有恶意字符！&quot;); Response.End(); &#125; &#125; &#125; protected void Application_AuthenticateRequest(object sender, EventArgs e) &#123; &#125; protected void Application_Error(object sender, EventArgs e) &#123; &#125; protected void Session_End(object sender, EventArgs e) &#123; &#125; protected void Application_End(object sender, EventArgs e) &#123; &#125; &#125;&#125; 2、SafeHelper.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Text.RegularExpressions;using System.Web;namespace MxWeiXinPF.Common&#123; public class SafeHelper &#123; private const string StrRegex = @&quot;\b(alert|confirm|prompt)\b|^\+/v(8|9)|\b(and|or)\b.&#123;1,6&#125;?(=|&gt;|&lt;|\bin\b|\blike\b)|/\*.+?\*/|&lt;\s*script\b|&lt;\s*img\b|\bEXEC\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\s+(TABLE|DATABASE)&quot;; public static bool PostData() &#123; bool result = false; for (int i = 0; i &lt; HttpContext.Current.Request.Form.Count; i++) &#123; result = CheckData(HttpContext.Current.Request.Form[i].ToString()); if (result) &#123; break; &#125; &#125; return result; &#125; public static bool GetData() &#123; bool result = false; for (int i = 0; i &lt; HttpContext.Current.Request.QueryString.Count; i++) &#123; result = CheckData(HttpContext.Current.Request.QueryString[i].ToString()); if (result) &#123; break; &#125; &#125; return result; &#125; public static bool CookieData() &#123; bool result = false; for (int i = 0; i &lt; HttpContext.Current.Request.Cookies.Count; i++) &#123; result = CheckData(HttpContext.Current.Request.Cookies[i].Value.ToLower()); if (result) &#123; break; &#125; &#125; return result; &#125; public static bool referer() &#123; bool result = false; return result = CheckData(HttpContext.Current.Request.UrlReferrer.ToString()); &#125; public static bool CheckData(string inputData) &#123; if (Regex.IsMatch(inputData, StrRegex)) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密解密(c#与js版)]]></title>
    <url>%2F2017%2F11%2F29%2FRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86-c-%E4%B8%8Ejs%E7%89%88%2F</url>
    <content type="text"><![CDATA[业务描述：前端js使用私有秘钥将数据进行加密，后端C#在一般处理程序中使用公钥对加密数据进行解密。 问题描述：1、C#自有类RSACryptoServiceProvider生成RSA的秘钥与公钥的方法ToXmlString(true)秘钥，ToXmlString(false)公钥，结果是XML形式的，js无法直接使用，js所使用的是PEM形式的秘钥。解决方法：使用工具类bouncycastle直接生成PEM版的秘钥和公钥，后台使用时，再将秘钥转换为XML版的。引用地址：https://www.bouncycastle.org/插件下载地址：https://downloads.bouncycastle.org/csharp/bccrypto-csharp-1.8.1-bin.zip 2、js加密数据后base64位的数据在传输中“+”号会变为空格，导致后台C#解密出错。解决方法：js先加号转后，然后后台再将加号转回。 3、网页版的加密解密demo以固定的秘钥形式来实现，实际案例中可以考虑更改为使用session保存针对单个用户来生成的公钥和秘钥。 参考地址：http://www.sufeinet.com/forum.php?mod=viewthread&amp;tid=5484&amp;highlight=RSAhttps://www.cnblogs.com/Leo_wl/p/5763243.html 控制台应用程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using Org.BouncyCastle.Asn1.Pkcs;using Org.BouncyCastle.Asn1.X509;using Org.BouncyCastle.Crypto;using Org.BouncyCastle.Crypto.Generators;using Org.BouncyCastle.Crypto.Parameters;using Org.BouncyCastle.Pkcs;using Org.BouncyCastle.Security;using Org.BouncyCastle.X509;using System;using System.Security.Cryptography;using System.Text;namespace RSAGenerateKey&#123; class Program &#123; static void Main(string[] args) &#123; RsaKeyPairGenerator g = new RsaKeyPairGenerator(); g.Init(new KeyGenerationParameters(new SecureRandom(), 1024)); var pair = g.GenerateKeyPair(); PrivateKeyInfo privateKeyInfo = PrivateKeyInfoFactory.CreatePrivateKeyInfo(pair.Private); byte[] serializedPrivateBytes = privateKeyInfo.ToAsn1Object().GetDerEncoded(); string serializedPrivate = Convert.ToBase64String(serializedPrivateBytes);//PEM秘钥 SubjectPublicKeyInfo publicKeyInfo = SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(pair.Public); byte[] serializedPublicBytes = publicKeyInfo.ToAsn1Object().GetDerEncoded(); string serializedPublic = Convert.ToBase64String(serializedPublicBytes);//PEM公钥 RsaPrivateCrtKeyParameters privateKey = (RsaPrivateCrtKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(serializedPrivate)); RsaKeyParameters publicKey = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(serializedPublic)); RSACryptoServiceProvider rcsp = new RSACryptoServiceProvider(); RSAParameters parms = new RSAParameters(); //So the thing changed is offcourse the ToByteArrayUnsigned() instead of //ToByteArray() parms.Modulus = privateKey.Modulus.ToByteArrayUnsigned(); parms.P = privateKey.P.ToByteArrayUnsigned(); parms.Q = privateKey.Q.ToByteArrayUnsigned(); parms.DP = privateKey.DP.ToByteArrayUnsigned(); parms.DQ = privateKey.DQ.ToByteArrayUnsigned(); parms.InverseQ = privateKey.QInv.ToByteArrayUnsigned(); parms.D = privateKey.Exponent.ToByteArrayUnsigned(); parms.Exponent = privateKey.PublicExponent.ToByteArrayUnsigned(); //So now this now appears to work. rcsp.ImportParameters(parms); string s = rcsp.ToXmlString(true); string privateKeyXmlText = rcsp.ToXmlString(true);//XML秘钥 string publicKeyXmlText = rcsp.ToXmlString(false);//XML公钥 //加密解密 string texta1 = &quot;abc&quot;,texta2=&quot;&quot;,textb1=&quot;&quot;; byte[] cipherbytes; cipherbytes = rcsp.Encrypt(Encoding.UTF8.GetBytes(texta1), false); texta2 = Convert.ToBase64String(cipherbytes); cipherbytes = rcsp.Decrypt(Convert.FromBase64String(texta2), false); textb1= Encoding.UTF8.GetString(cipherbytes); Console.Read(); &#125; &#125;&#125; 版本一 版本一： 未能解决问题：在使用过程中偶尔会出现无法解密的异常，用户a8176a4c-5b7e-4f1d-94d8-04e744332f76进行分数/H544nYvvBRPZQAIQfDGHMySy/svCbS8/uUwwv5Fc6hKlTed9XvwuEYeAKv22cdPXDV%2B6/tmduEuVJDCP7G8Jb2TxJdN9A%2Bwou%2BGnOTO7%2BTo6yA2KX4Uvriof5yCt1ONmkLbsPRVh0/cnjnogJwLk2U/FVggjIhcOP6Rq%2BzLOw==的提交操作,发生异常不正确的数据。本地直接使用测试demo可以解密，所以无法找到出问题的原因。！！！！2、网页版本webform 前台网页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;login.aspx.cs&quot; Inherits=&quot;RSADemo.login&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head runat=&quot;server&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://passport.cnblogs.com/scripts/jsencrypt.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/node-forge@0.7.0/dist/forge.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; //pem公钥 var pemPublicKey = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHCkaSCVy6sHB/5rAKS/1EEtyzWuy30gLyrpNbFI3GtpsdFGdsqQ/uwiscGD+pZ7Mxj1ZumPs4jHvPpcAeCb8gKsqP/f5+pputTMuTkhTQqlDT1plHR7w3REQI8MaJ8KTA/pJiPo6iWToFynQeJNWjicxXxNURSZQ7nmC2rl4uPQIDAQAB&quot;; $(&quot;#tra&quot;).val(pemPublicKey); var encrypt = new JSEncrypt(); encrypt.setPublicKey($(&quot;#tra&quot;).val()); var data = encrypt.encrypt(&quot;123456789&quot;); alert(data); $(&quot;#btn&quot;).click(function () &#123; $.ajax(&#123; url: &apos;Handler1.ashx&apos;, data: &quot;pwd=&quot; +encodeURI(data).replace(/\+/g, &apos;%2B&apos;), //+号的处理：因为数据在网络上传输时，非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，而base64编码在传输到后端的时候，+会变成空格，因此先替换掉。后端再替换回来 type: &apos;post&apos;, success: function (msg) &#123; alert(msg); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;点我&quot; /&gt; &lt;textarea id=&quot;tra&quot; rows=&quot;15&quot; cols=&quot;65&quot;&gt; &lt;/textarea&gt; &lt;hr /&gt; 注意+好的处理 &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台ashx一般处理程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Security.Cryptography;using System.Text;using System.Web;namespace RSADemo&#123; /// &lt;summary&gt; /// Summary description for Handler1 /// &lt;/summary&gt; public class Handler1 : IHttpHandler &#123; public void ProcessRequest(HttpContext context) &#123; string result = &quot;&quot;; //XML密钥 string privateKey = @&quot;&lt;RSAKeyValue&gt;&lt;Modulus&gt;xwpGkglcurBwf+awCkv9RBLcs1rst9IC8q6TWxSNxrabHRRnbKkP7sIrHBg/qWezMY9Wbpj7OIx7z6XAHgm/ICrKj/3+fqabrUzLk5IU0KpQ09aZR0e8N0RECPDGifCkwP6SYj6Oolk6Bcp0HiTVo4nMV8TVEUmUO55gtq5eLj0=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/LnrFrusoNklOl6d0zSWZ1aCdQC2l3XXU8SSgYNLuSmgVwl7wQ2w0Jn9SQqyiVRmbcp1SX28/bH6TaA2v9ejHQ==&lt;/P&gt;&lt;Q&gt;yZ5TTtLOfTqrikYjy/fyktTk977y2GG2R9sgNPHtnH5EIIC9CoJETDwfSu40YUlHeUUXHQ1nG1WmWbEOC76toQ==&lt;/Q&gt;&lt;DP&gt;5UfC+YfgkLkQJklqxA+EmFIK3x17iiO16+B9zhQQ4fba6bvH05iZHldmTBrxaNfyaY7xI3B4wmzymfRNV3TKHQ==&lt;/DP&gt;&lt;DQ&gt;k7EvRaaXLJU14+zNfDT9tSHPOMzgCDJL3Qdf6GjwrpqwPT8RPAmBDndcVP95z2pmuScrb1TKGvP7D+jraR8dAQ==&lt;/DQ&gt;&lt;InverseQ&gt;4gbDpW7ca3dn0XXPkYsVmIl7SBqU8lq9X2xji/Nyg1M0pjDcpdQm0bqOm+/5usQl+kRotpIoK+Yf6J++zbmNjg==&lt;/InverseQ&gt;&lt;D&gt;Ccxfc356/mTDsQQv+93ISsLb8wdhml4AD6bY8bWmEhd4tNqFieObuW79FM27ypDkkSbDhD/LNDo0OSFpfwEPU8VxnEMzFnVw7MIWGSVKWocZHIhsclkHtHNtHaKS0LNEie2q0PGMiIYty/QG5k3bJeA8R42teXv3nARYEgzuNmE=&lt;/D&gt;&lt;/RSAKeyValue&gt;&quot;; try &#123; string pwd = context.Request[&quot;pwd&quot;]; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privateKey); //把+号，再替换回来 cipherbytes = rsa.Decrypt(Convert.FromBase64String(pwd.Replace(&quot;%2B&quot;, &quot;+&quot;)), false); result = Encoding.UTF8.GetString(cipherbytes); &#125; catch (Exception exception) &#123; &#125; context.Response.Write(result); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125;&#125; 版本二 版本二： 直接使用RSACryptoServiceProvider类生成xml的公钥和秘钥，放入session中该版本用到了四个js。下载地址：https://pan.baidu.com/s/1boQox8V1234&lt;script src="Scripts/jquery-1.4.1.js"&gt;&lt;/script&gt;&lt;script src="Scripts/Barrett.js"&gt;&lt;/script&gt;&lt;script src="Scripts/BigInt.js"&gt;&lt;/script&gt;&lt;script src="Scripts/RSA.js"&gt;&lt;/script&gt; 前台代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Login.aspx.cs" Inherits="RSAWeb.Login" %&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head runat="server"&gt; &lt;title&gt;登录页RSA加密解密demo&lt;/title&gt; &lt;script src="Scripts/jquery-1.4.1.js"&gt;&lt;/script&gt; &lt;script src="Scripts/Barrett.js"&gt;&lt;/script&gt; &lt;script src="Scripts/BigInt.js"&gt;&lt;/script&gt; &lt;script src="Scripts/RSA.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function cmdEncrypt() &#123; //关键步骤 setMaxDigits(129); var key = new RSAKeyPair("&lt;%=strPublicKeyExponent%&gt;", "", "&lt;%=strPublicKeyModulus%&gt;"); var pwdMD5Twice = $("#txtPassword").attr("value"); var pwdRtn = encryptedString(key, pwdMD5Twice); //关键步骤 $("#encrypted_pwd").attr("value", pwdRtn); $("#formLogin").submit(); return; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="Login.aspx" id="formLogin" method="post"&gt; &lt;div&gt; &lt;div&gt; User Name: &lt;/div&gt; &lt;div&gt; &lt;input id="txtUserName" name="txtUserName" value="&lt;%=postbackUserName%&gt;" type="text" maxlength="16" /&gt; &lt;/div&gt; &lt;div&gt; Password: &lt;/div&gt; &lt;div&gt; &lt;input id="txtPassword" type="password" maxlength="16" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id="btnLogin" type="button" value="Login" onclick="return cmdEncrypt()" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="hidden" name="encrypted_pwd" id="encrypted_pwd" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;div&gt; &lt;%=LoginResult%&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后台代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System;using System.Security.Cryptography;using System.Text;namespace RSAWeb&#123; public partial class Login : System.Web.UI.Page &#123; protected string strPublicKeyExponent = &quot;&quot;; protected string strPublicKeyModulus = &quot;&quot;; protected string LoginResult = &quot;&quot;; protected string postbackUserName = &quot;&quot;; protected void Page_Load(object sender, EventArgs e) &#123; LoginResult = &quot;&quot;; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); if (string.Compare(Request.RequestType, &quot;get&quot;, true) == 0) &#123; //将私钥存Session中 Session[&quot;private_key&quot;] = rsa.ToXmlString(true); CYQ.Data.Log.WriteLogToTxt(Convert.ToString(Session[&quot;private_key&quot;]), CYQ.Data.LogType.Debug); &#125; else &#123; bool bLoginSucceed = false; try &#123; string strUserName = Request.Form[&quot;txtUserName&quot;]; postbackUserName = strUserName; string strPwdToDecrypt = Request.Form[&quot;encrypted_pwd&quot;]; rsa.FromXmlString((string)Session[&quot;private_key&quot;]); byte[] result = rsa.Decrypt(HexStringToBytes(strPwdToDecrypt), false); System.Text.ASCIIEncoding enc = new ASCIIEncoding(); string strPwdMD5 = enc.GetString(result); if (string.Compare(strUserName, &quot;admin&quot;, true) == 0 &amp;&amp; string.Compare(strPwdMD5, &quot;admin&quot;, true) == 0)//14e1b600b1fd579f47433b88e8d85291 bLoginSucceed = true; &#125; catch (Exception) &#123; &#125; if (bLoginSucceed) LoginResult = &quot;登录成功&quot;; else LoginResult = &quot;登录失败&quot;; &#125; //把公钥适当转换，准备发往客户端 RSAParameters parameter = rsa.ExportParameters(true); strPublicKeyExponent = BytesToHexString(parameter.Exponent); strPublicKeyModulus = BytesToHexString(parameter.Modulus); &#125; private string BytesToHexString(byte[] input) &#123; StringBuilder hexString = new StringBuilder(64); for (int i = 0; i &lt; input.Length; i++) &#123; hexString.Append(String.Format(&quot;&#123;0:X2&#125;&quot;, input[i])); &#125; return hexString.ToString(); &#125; public static byte[] HexStringToBytes(string hex) &#123; if (hex.Length == 0) &#123; return new byte[] &#123; 0 &#125;; &#125; if (hex.Length % 2 == 1) &#123; hex = &quot;0&quot; + hex; &#125; byte[] result = new byte[hex.Length / 2]; for (int i = 0; i &lt; hex.Length / 2; i++) &#123; result[i] = byte.Parse(hex.Substring(2 * i, 2), System.Globalization.NumberStyles.AllowHexSpecifier); &#125; return result; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流操作]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%B5%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C#常用流操作 文件流 FileStream流读取器 StreamReader流写入器 StreamWriter 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;namespace FileStreamStudy&#123; class Program &#123; static void Main(string[] args) &#123; // 文件流和读取写入器操作完后，需要调用close()方法进行关闭 //读文件流 using (FileStream stream = new FileStream("D:\\license.xml", FileMode.OpenOrCreate))//文件地址，文件读取模式FileMode枚举类 &#123; //流读取器 using (StreamReader reader = new StreamReader(stream)) &#123; string currentLine = reader.ReadLine();//读取一行 while (!string.IsNullOrEmpty(currentLine)) &#123; Console.WriteLine(currentLine); currentLine = reader.ReadLine(); &#125; &#125; &#125; //写文件流 using (FileStream stream = new FileStream("d:\\1.txt", FileMode.Append)) &#123; //流写入器 using (StreamWriter writer = new StreamWriter(stream)) &#123; string s = "12345"; writer.WriteLine(s); writer.Flush();//清空缓存 &#125; &#125; Console.Read(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml序列化]]></title>
    <url>%2F2017%2F08%2F16%2Fxml%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[可能目前系统之间接口多数以JSON或者XML形式进行数据的传输，项目中用到了XML，但是没有使用下面介绍的以序列化的形式将XML与对象进行互转，当时为了多个实现方案所以做了一些准备，先总结XML序列化与反序列化的使用基础，备用吧。 基础类及基础方法 代码实现 总结及出现的问题 基础类及基础方法 基础类主要是：System.Xml.Serialization.XmlSerializerXmlSerializer类主要功能是将对象和XML文档之间进行序列化和发序列化。XmlSerializer可以方便将对象编码为XML。 1、构造器创建XmlSerializer对象12//创建新实例并指定改实例可以用来序列化和反序列化的类的类型XmlSerializer xmlSerializer=new XmlSerializer(Type); 2、XmlSerializer对象序列化对象12//将对象Object序列化到TextWriter中xmlSerializer.Serialize(TextWriter,Object); TextWriter是一个有序序列字符的编写器，它是一个抽象类，常用的有两个子类即：StreamWriter（写入流） 和 StringWriter（写入字符串）.因此在实际使用时，这里选择System.IO.StringWriter。 这里需要注意，如果要指定序列化后XML的编码类型，StringWriter有一个属性Encoding,但是该属性只读，无法进行设置，因此需要写一个子类来覆盖Encoding的属性。 123456789public sealed class Utf8StringWriter : StringWriter &#123; //指定编码类型是UTF-8 public override Encoding Encoding &#123; get &#123; return Encoding.UTF8; &#125; &#125; &#125; //将对象Object序列化到TextWriter的子类Utf8StringWriter中xmlSerializer.Serialize(Utf8StringWriter,Object); 3、获得序列化后的结果1string XMLResult=Utf8StringWriter.ToString(); 4、通过特性Attritube设置自定义类的序列化结果System.Xml.Serialization命名空间中有一系列的特性类，用来控制复杂类型序列化的控制。例如XmlElementAttribute、XmlAttributeAttribute、XmlArrayAttribute、XmlArrayItemAttribute、XmlRootAttribute等等。序列化帮助 代码实现完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149using System;using System.IO;using System.Reflection;using System.Text;using System.Xml;using System.Xml.Serialization;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; SERVICE service = new SERVICE(); HEAD head = service.HEAD; head.nsrsbh = "140115728183815"; head.serviceversion = "1.3"; head.serviceid = "jy.dzptfpkj"; head.iszip = "N"; head.encryptcode = "0"; head.issyn = "Y"; service.Cmd = new Cmd[] &#123;new Cmd(),new Cmd() &#125;; //序列化这个对象 XmlSerializer serializer = new XmlSerializer(service.GetType()); using (Utf8StringWriter writer = new Utf8StringWriter()) &#123; serializer.Serialize(writer, service); Console.WriteLine(writer.ToString()); &#125; Console.Read(); &#125; &#125; public class BaseObject &#123; public BaseObject() &#123; Type t = this.GetType();//构造器获得当前类型 PropertyInfo[] list=t.GetProperties();//获得所有属性 foreach (PropertyInfo item in list) &#123; object[] objAttrs = item.GetCustomAttributes(typeof(XmlElementAttribute), true);//获得所有XmlElement特性 if (objAttrs != null &amp;&amp; objAttrs.Length &gt; 0) &#123; XmlElementAttribute attr = objAttrs[0] as XmlElementAttribute; //Console.WriteLine(attr.ElementName); attr.IsNullable = true;//将特性设置为可空 &#125; if (IsType(item.PropertyType, "System.String")) &#123; item.SetValue(this, string.Empty, null);//将字符串类型属性的值设置为空字符串 &#125; &#125; &#125; /// &lt;summary&gt; /// 类型匹配 /// &lt;/summary&gt; /// &lt;param name="type"&gt;&lt;/param&gt; /// &lt;param name="typeName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsType(Type type, string typeName) &#123; if (type.ToString() == typeName) return true; if (type.ToString() == "System.Object") return false; return IsType(type.BaseType, typeName); &#125; &#125; [XmlRoot("SERVICE")] public class SERVICE: BaseObject &#123; public SERVICE() &#123; this.HEAD = new HEAD(); &#125; [XmlElement("HEAD")] public HEAD HEAD &#123; get; set; &#125; [XmlArray("BODY")] [XmlArrayItem("cmd")] public Cmd[] Cmd &#123; get; set; &#125; &#125; public class HEAD : BaseObject &#123; public HEAD() &#123; this.RTNINF = new RTNINF(); &#125; [XmlElement("nsrsbh")] public string nsrsbh &#123; get; set; &#125; [XmlElement("serviceversion")] public string serviceversion &#123; get; set; &#125; [XmlElement("serviceid")] public string serviceid &#123; get; set; &#125; [XmlElement("iszip")] public string iszip &#123; get; set; &#125; [XmlElement("encryptcode")] public string encryptcode &#123; get; set; &#125; [XmlElement("issyn")] public string issyn &#123; get; set; &#125; [XmlElement("RTNINF")] public RTNINF RTNINF &#123; get; set; &#125; &#125; public class RTNINF : BaseObject &#123; [XmlElement("rtn_code")] public string rtn_code &#123; get; set; &#125; [XmlElement("rtn_reason")] public string rtn_reason &#123; get; set; &#125; &#125; public sealed class Utf8StringWriter : StringWriter &#123; public override Encoding Encoding &#123; get &#123; return Encoding.UTF8; &#125; &#125; &#125; public class Cmd : BaseObject &#123; [XmlElement("productid")] public string ProductId &#123; get; set; &#125; [XmlElement("price")] public string Price &#123; get; set; &#125; [XmlElement("date")] public string Date &#123; get; set; &#125; [XmlElement("state")] public string State &#123; get; set; &#125; [XmlElement("type")] public string Type &#123; get; set; &#125; &#125; &#125; 总结问题1、项目需要，所有的对象属性都要生成XML，即如果属性是空值，默认序列化XML后不会显示，所以把所有对象都继承自BaseObject类下，再使用BaseObject类的构造器通过反射子类中特性的方法，在初始化子类时，将空字符串写入，这样最后生成XML文件时，空字符串的属性也会显示了。 反射时使用了的类及方法包括Object.GetType()根据对象获得类型,Type.GetProperties()根据类型获得说有属性,PropertyInfo.GetCustomAttributes根据属性获得所有特性，父类BaseObject 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940 public class BaseObject&#123; public BaseObject() &#123; Type t = this.GetType();//构造器获得当前类型 PropertyInfo[] list=t.GetProperties();//反射获得所有属性 foreach (PropertyInfo item in list) &#123; object[] objAttrs = item.GetCustomAttributes(typeof(XmlElementAttribute), true);//获得所有XmlElement特性 if (objAttrs != null &amp;&amp; objAttrs.Length &gt; 0) &#123; XmlElementAttribute attr = objAttrs[0] as XmlElementAttribute; //Console.WriteLine(attr.ElementName); attr.IsNullable = true;//将特性设置为可空 &#125; if (IsType(item.PropertyType, "System.String")) &#123; item.SetValue(this, string.Empty, null);//将字符串类型属性的值设置为空字符串 &#125; &#125; &#125; /// &lt;summary&gt; /// 类型匹配 /// &lt;/summary&gt; /// &lt;param name="type"&gt;&lt;/param&gt; /// &lt;param name="typeName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsType(Type type, string typeName) &#123; if (type.ToString() == typeName) return true; if (type.ToString() == "System.Object") return false; return IsType(type.BaseType, typeName); &#125;&#125; 2、SERVICE类下的Cmd属性比较特殊，它是一个数组，通过XmlArray特性和XmlArrayItem特性配合使用后，如下： [XmlArray(“BODY”)] [XmlArrayItem(“cmd”)] public Cmd[] Cmd { get; set; } 序列化XML后生成的效果如下： 123456&lt;BODY&gt; &lt;cmd&gt;&lt;/cmd&gt; &lt;cmd&gt;&lt;/cmd&gt; &lt;cmd&gt;&lt;/cmd&gt; &lt;cmd&gt;&lt;/cmd&gt;&lt;/BODY&gt;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信公众号集合支付宝支付]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%9B%86%E5%90%88%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[微信公众号集合支付宝支付 支付宝支付有多种方式，其中手机网站支付满足微信公众号内集成的要求，所以这篇文章即同时描述支付宝手机网站支付。 配置基础信息 API及业务逻辑 代码实现 总结及出现的问题 配置基础信息 [x] 给企业注册支付宝账号 [x] 创建自用型应用 [x] 添加并签约手机网站支付需要首先在网站内签约开通手机网站支付的权限。 API及业务逻辑手机网站支付API可以前往以下网址查看及下载sdk：目前手机网站支付demo有： JAVA和PHP版本SDK则有：JAVA、.NET和PHP版本 手机支付APISDK下载微信公众号集成帮助包签名sign生成规则代码实现###普通手机网站用户进行确认下单页面 12345678910111213141516171819202122232425262728293031323334353637383940414243 namespace AliPayDemo&#123; public partial class Pay : System.Web.UI.Page &#123; //不是真实数据 string APPID = "2017090907474487";//应用ID //应用私钥 string APP_PRIVATE_KEY = @"****JEwKBgQCIFY+12QuI3gI478vsixJiYOWJb2T7MRr0Zlg2n3fnQWnVB2gOkSgls/CHM3y+d/GQRJRE5aFWa2Xt"; //支付宝公钥 string ALIPAY_PUBLIC_KEY = @"***PXZOf8eQx+qWGky6LJZWie4IF2oqY7El1nps2qVg1IbQkDdIMNSr2a2nQF5GwSpVcF7bRZeNG2qgs3EjHu4hGqXMWbg6Fvs1iigiBYfkzQIDAQAB"; string CHARSET = "utf-8";//编码格式 protected void Page_Load(object sender, EventArgs e) &#123; //SDK已经封装掉了公共参数，只需要初始化一次 IAopClient client = new DefaultAopClient("https://openapi.alipay.com/gateway.do", APPID, APP_PRIVATE_KEY, "json", "1.0", "RSA2", ALIPAY_PUBLIC_KEY, CHARSET, false); //实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称如：alipay.trade.wap.pay.request AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); //SDK已经封装掉了公共参数，这里只需要传入业务参数 //此次只是参数展示，未进行字符串转义，实际情况下请转义 //注意value类型，如金额没有引号， request.BizContent = "&#123;" + " \"subject\":\"大乐透\"," + " \"out_trade_no\":\"70501111111S0011111191\"," + " \"total_amount\":0.01," + " \"product_code\":\"QUICK_WAP_WAY\"" + " &#125;"; AlipayTradeWapPayResponse response = client.pageExecute(request); divBody.InnerHtml = response.Body; ////调用成功，则处理业务逻辑 //if (response.IsError) //&#123; // //..... //&#125; &#125; &#125;&#125; ###微信公众号内用户进行确认下单页面1、下载集成微信公众号的帮助包并将文件放入项目文件夹中 ap.js 跳转到自带浏览器js pay.htm 提示用户跳转htm页面1、使用pageExecute方法，以GET方式获得url字符串；12AlipayTradeWapPayResponse response = client.pageExecute(request,null,&quot;GET&quot;); test = response.Body; 2、将Url传入前台页面标签，待用户点击确定1&lt;a id="test" href="&lt;%=test%&gt;" class="button button-big button-fill"&gt;支付宝结算&lt;/a&gt; 3、用户点击页面后跳转到提示页，提示用户使用手机自带浏览器打开连接 4、完成支付 5、整体的代码 前端123456789101112131415161718192021222324252627282930313233 &lt;%@ Page Language="C#" AutoEventWireup="true" CodeFile="JsApiPayPage1.aspx.cs" Inherits="JsApiPayPage1" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head runat="server"&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;title&gt;微信支付&lt;/title&gt;&lt;/head&gt;&lt;body style="background-color: #efeff4;"&gt; &lt;form runat="server" id="calculator" v-cloak&gt; &lt;div class="content-block"&gt; &lt;a id="test" href="&lt;%=test%&gt;" class="button"&gt;支付宝结算&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//绑定单击事件 var btn = document.querySelector("#test"); btn.addEventListener("click", function (e) &#123; e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); //ele.href 是GET到支付宝收银台的URL _AP.pay(e.target.href); return false; &#125;, false);&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using CYQ.Data;using Web.Lianmengban_2016;using CYQ.Data.Table;using Aop.Api.Util;using Aop.Api;using Aop.Api.Request;using Aop.Api.Response;public partial class JsApiPayPage1 : System.Web.UI.Page&#123; public static string test &#123; get; set; &#125; protected void Page_Load(object sender, EventArgs e) &#123; CreateAliPayPramaters(); &#125; private void CreateAliPayPramaters() &#123; //pageExecute&lt;T&gt;(IAopRequest&lt;T&gt; request, string accessToken, string reqMethod) where T : AopResponse IAopClient client = new DefaultAopClient("https://openapi.alipay.com/gateway.do", AliConfig.APP_ID, AliConfig.APP_PRIVATE_KEY, "json", "1.0", "RSA2", AliConfig.ALIPAY_PUBLIC_KEY, AliConfig.CHARSET, false); //实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称如：alipay.open.public.template.message.industry.modify AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); //AlipayOpenPublicTemplateMessageIndustryModifyRequest request = new AlipayOpenPublicTemplateMessageIndustryModifyRequest(); //SDK已经封装掉了公共参数，这里只需要传入业务参数 //此次只是参数展示，未进行字符串转义，实际情况下请转义 request.BizContent = "&#123;" + " \"subject\":\"大乐透\"," + " \"out_trade_no\":\"70501111111S0011111191\"," + " \"total_amount\":0.01," + " \"product_code\":\"QUICK_WAP_WAY\"" + " &#125;"; AlipayTradeWapPayResponse response = client.pageExecute(request,null,"GET"); test = response.Body; &#125; &#125; 12345678910111213141516public class AliConfig&#123; //=======【基本信息设置】===================================== /* 支付宝手机网页支付信息配置 public const string URL = "https://openapi.alipay.com/gateway.do"; public const string APP_ID = "20170111111144"; public const string APP_PRIVATE_KEY = @"MIIEowIBAAKCAQEA31kawX3d***t"; public const string FORMAT = "json"; public const string CHARSET = "utf-8"; public const string ALIPAY_PUBLIC_KEY = @"MIIBIjANBgkqhkiG9***"; public const string SIGN_TYPE = "RSA2"; public const string SELLER_EMAIL = "1234@123.com"; public const string NOTIFY_URL = "http://www.222.net/ResultNotifyAliPay.aspx"; public const string RETURN_URL = "http://www.222.net/AliReturnPage.aspx";&#125; 总结及出现的问题1、参数的内容按照api提供的列表把必填项的key及value一定要写全，写对；2、BizContent的业务参数内多个参数之间用“，”号隔开，之前忘记写全，报错；3、签名错误sign_valid API里面生成签名，包括sign_type接收支付宝的异步通知时，验签之前不包括sign 和 sign_type 签名sign生成规则支付宝官方sdk有个bug，Aop.Api.Util.AlipaySignature类中方法没有去掉sign_type就进行验证，导致出错； 1234567891011121314151617181920212223242526272829303132 public static bool RSACheckV2(IDictionary&lt;string, string&gt; parameters, string publicKeyPem) &#123; string sign = parameters["sign"]; parameters.Remove("sign"); parameters.Remove("sign_type");//新增修改bug string signContent = GetSignContent(parameters); return RSACheckContent(signContent, sign, publicKeyPem, DEFAULT_CHARSET, "RSA"); &#125; public static bool RSACheckV2(IDictionary&lt;string, string&gt; parameters, string publicKeyPem, string charset) &#123; string sign = parameters["sign"]; parameters.Remove("sign"); parameters.Remove("sign_type");//新增修改bug string signContent = GetSignContent(parameters); return RSACheckContent(signContent, sign, publicKeyPem, charset, "RSA"); &#125;public static bool RSACheckV2(IDictionary&lt;string, string&gt; parameters, string publicKeyPem, string charset, string signType, bool keyFromFile) &#123; string sign = parameters["sign"]; parameters.Remove("sign"); parameters.Remove("sign_type");//新增修改bug string signContent = GetSignContent(parameters); return RSACheckContent(signContent, sign, publicKeyPem, charset, signType, keyFromFile); &#125; 4、交易订单处理失败 请稍后再试 ali38173转到支付宝时，弹出这个错误，找了很久，才发现是由于Bizcontent的最后一个}括号内包含一个全角的空格，很坑啊；]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.net动态控制发布IIS网站（一）]]></title>
    <url>%2F2017%2F06%2F20%2Fnet%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6%E5%8F%91%E5%B8%83IIS%E7%BD%91%E7%AB%99%E4%B8%80%2F</url>
    <content type="text"><![CDATA[资料1.Microsoft.Web.Administration IIS操作API 代码简介主要逻辑功能 拷贝网站发布文件夹-&gt;IIS创建站点(获得空闲端口)-&gt;绑定域名 涉及到两个工具类1、IISManager IIS管理类2、DirFileHelper 文件及文件夹操作类 代码详情12345678910111213141516171819202122232425262728293031323334353637383940using CommonTools;using System;using System.Collections;namespace IIS&#123; class Program &#123; static void Main(string[] args) &#123; string folderName = "D:\\WebSiteTest";//发布网站目录 string physicsPath = "D:\\WebSite0421";//模板网站目录 ArrayList ports = IISManager.GetAllUsePorts(); for (int i = 0; i &lt; 30; i++) &#123; string port = IISManager.GetFreePort(ref ports); //Console.WriteLine(port); string currentWebsiteName = "WebSite" + i; string currentPath = folderName + "\\" + currentWebsiteName; DirFileHelper.CopyFolder(physicsPath, currentPath); IISManager.CreateWebSite(currentWebsiteName, currentPath, port); IISManager.BindHost(currentWebsiteName, "www.baidu.com" + i); System.Console.WriteLine("网站名：" + currentWebsiteName + "端口号：" + port + "路径：" + currentPath + " 域名:" + "www.baidu.com" + i); &#125; //for (int i = 0; i &lt; 30; i++) //&#123; // IISManager.DeleteWebSite("WebSite" + i); //&#125; Console.ReadKey(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325using Microsoft.Web.Administration;using System;using System.Collections;using System.Diagnostics;using System.IO;using System.Text.RegularExpressions;namespace CommonTools&#123; public static class IISManager &#123; private static ServerManager serverManager = new ServerManager(); /// &lt;summary&gt; /// 创建站点 /// &lt;/summary&gt; /// &lt;param name="websiteName"&gt;站点名&lt;/param&gt; /// &lt;param name="physicsPath"&gt;物理路径&lt;/param&gt; /// &lt;param name="ip"&gt;ip地址&lt;/param&gt; /// &lt;param name="port"&gt;端口号&lt;/param&gt; /// &lt;param name="poolver"&gt;应用程序池的DOTNET FRAMEWORK版本&lt;/param&gt; /// &lt;param name="binding"&gt;使用的协议&lt;/param&gt; public static void CreateWebSite(string websiteName, string physicsPath, string port, string ip = "*", string poolver = "v4.0", string binding = "http") &#123; try &#123; string fullIP = ip + ":" + port + ":"; ApplicationPool newPool = serverManager.ApplicationPools.Add(websiteName); newPool.ManagedRuntimeVersion = poolver; Site mySide = serverManager.Sites.Add(websiteName, binding, fullIP, physicsPath); mySide.Applications[0].ApplicationPoolName = websiteName; serverManager.CommitChanges(); &#125; catch (Exception error) &#123; &#125; &#125; /// &lt;summary&gt; /// 删除站点 /// &lt;/summary&gt; /// &lt;param name="websiteName"&gt;站点名称&lt;/param&gt; public static void DeleteWebSite(string websiteName) &#123; serverManager.Sites.Remove(serverManager.Sites[websiteName]); serverManager.ApplicationPools.Remove(serverManager.ApplicationPools[websiteName]); serverManager.CommitChanges(); &#125; /// &lt;summary&gt; /// 获得空闲端口 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static ArrayList GetAllUsePorts() &#123; Process p = new Process(); p.StartInfo.FileName = "cmd.exe";//设置启动的应用程序 p.StartInfo.UseShellExecute = false;//禁止使用操作系统外壳程序启动进程 p.StartInfo.RedirectStandardInput = true;//应用程序的输入从流中读取 p.StartInfo.RedirectStandardOutput = true;//应用程序的输出写入流中 p.StartInfo.RedirectStandardError = true;//将错误信息写入流 p.StartInfo.CreateNoWindow = true;//是否在新窗口中启动进程 p.Start(); //p.StandardInput.WriteLine(@"netstat -a -n&gt;c:\port.txt");//将字符串写入文本流 p.StandardInput.WriteLine(@"netstat -a -n"); p.StandardInput.WriteLine("exit"); string str; StreamReader reader = p.StandardOutput; str = reader.ReadLine(); ArrayList ports = new ArrayList(); ////匹配出端口号 string pattern = @":\d+"; //正则表达式字符串 Regex regex = new Regex(pattern); while (!reader.EndOfStream) &#123; Match match = regex.Match(str); if (match.Success) &#123; string port = match.Groups[0].Value.Substring(1); ports.Add(int.Parse(port)); &#125; str = reader.ReadLine(); &#125; return ports; &#125; /// &lt;summary&gt; /// 追加绑定域名 /// &lt;/summary&gt; /// &lt;param name="websiteName"&gt;站点名&lt;/param&gt; /// &lt;param name="hostName"&gt;域名&lt;/param&gt; public static void BindHost(string websiteName, string hostName) &#123; BindingCollection bindings = serverManager.Sites[websiteName].Bindings; for (int i = 1; i &lt; bindings.Count; i++) &#123; serverManager.Sites[websiteName].Bindings.RemoveAt(i); &#125; serverManager.Sites[websiteName].Bindings.Add("*:80:" + hostName, "http"); serverManager.CommitChanges(); &#125; /// &lt;summary&gt; /// 获得当前IIS网站运行列表 /// &lt;/summary&gt; public static void GetListOfIIS() &#123; string StateStr = ""; for (int i = 0; i &lt; serverManager.Sites.Count; i++) &#123; switch (serverManager.Sites[i].State) &#123; case ObjectState.Started: &#123; StateStr = "正常"; break; &#125; case ObjectState.Starting: &#123; StateStr = "正在启动"; break; &#125; case ObjectState.Stopping: &#123; StateStr = "正在关闭"; break; &#125; case ObjectState.Stopped: &#123; StateStr = "关闭"; break; &#125; &#125; Console.WriteLine(serverManager.Sites[i].Name + "【" + StateStr + "】"); &#125; &#125; /// &lt;summary&gt; /// 获得当前IIS站点状态 /// &lt;/summary&gt; public static void ReadConfig() &#123; System.Console.WriteLine("应用程序池默认设置："); System.Console.WriteLine("\t常规："); System.Console.WriteLine("\t\t.NET Framework 版本：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ManagedRuntimeVersion); System.Console.WriteLine("\t\t队列长度：&#123;0&#125;", serverManager.ApplicationPoolDefaults.QueueLength); System.Console.WriteLine("\t\t托管管道模式：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ManagedPipelineMode.ToString()); System.Console.WriteLine("\t\t自动启动：&#123;0&#125;", serverManager.ApplicationPoolDefaults.AutoStart); System.Console.WriteLine("\tCPU："); System.Console.WriteLine("\t\t处理器关联掩码：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.SmpProcessorAffinityMask); System.Console.WriteLine("\t\t限制：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.Limit); System.Console.WriteLine("\t\t限制操作：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.Action.ToString()); System.Console.WriteLine("\t\t限制间隔（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.ResetInterval.TotalMinutes); System.Console.WriteLine("\t\t已启用处理器关联：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.SmpAffinitized); System.Console.WriteLine("\t回收："); System.Console.WriteLine("\t\t发生配置更改时禁止回收：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.DisallowRotationOnConfigChange); System.Console.WriteLine("\t\t固定时间间隔（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Time.TotalMinutes); System.Console.WriteLine("\t\t禁用重叠回收：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.DisallowOverlappingRotation); System.Console.WriteLine("\t\t请求限制：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Requests); System.Console.WriteLine("\t\t虚拟内存限制（KB）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Memory); System.Console.WriteLine("\t\t专用内存限制（KB）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.PrivateMemory); System.Console.WriteLine("\t\t特定时间：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Schedule.ToString()); System.Console.WriteLine("\t\t生成回收事件日志条目：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.LogEventOnRecycle.ToString()); System.Console.WriteLine("\t进程孤立："); System.Console.WriteLine("\t\t可执行文件：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.OrphanActionExe); System.Console.WriteLine("\t\t可执行文件参数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.OrphanActionParams); System.Console.WriteLine("\t\t已启用：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.OrphanWorkerProcess); System.Console.WriteLine("\t进程模型："); System.Console.WriteLine("\t\tPing 间隔（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.PingInterval.TotalSeconds); System.Console.WriteLine("\t\tPing 最大响应时间（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.PingResponseTime.TotalSeconds); System.Console.WriteLine("\t\t标识：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.IdentityType); System.Console.WriteLine("\t\t用户名：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.UserName); System.Console.WriteLine("\t\t密码：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.Password); System.Console.WriteLine("\t\t关闭时间限制（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.ShutdownTimeLimit.TotalSeconds); System.Console.WriteLine("\t\t加载用户配置文件：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.LoadUserProfile); System.Console.WriteLine("\t\t启动时间限制（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.StartupTimeLimit.TotalSeconds); System.Console.WriteLine("\t\t允许 Ping：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.PingingEnabled); System.Console.WriteLine("\t\t闲置超时（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.IdleTimeout.TotalMinutes); System.Console.WriteLine("\t\t最大工作进程数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.MaxProcesses); System.Console.WriteLine("\t快速故障防护："); System.Console.WriteLine("\t\t“服务不可用”响应类型：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.LoadBalancerCapabilities.ToString()); System.Console.WriteLine("\t\t故障间隔（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.RapidFailProtectionInterval.TotalMinutes); System.Console.WriteLine("\t\t关闭可执行文件：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.AutoShutdownExe); System.Console.WriteLine("\t\t关闭可执行文件参数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.AutoShutdownParams); System.Console.WriteLine("\t\t已启用：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.RapidFailProtection); System.Console.WriteLine("\t\t最大故障数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.RapidFailProtectionMaxCrashes); System.Console.WriteLine("\t\t允许32位应用程序运行在64位 Windows 上：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Enable32BitAppOnWin64); System.Console.WriteLine(); System.Console.WriteLine("网站默认设置："); System.Console.WriteLine("\t常规："); System.Console.WriteLine("\t\t物理路径凭据：UserName=&#123;0&#125;, Password=&#123;1&#125;", serverManager.VirtualDirectoryDefaults.UserName, serverManager.VirtualDirectoryDefaults.Password); System.Console.WriteLine("\t\t物理路径凭据登录类型：&#123;0&#125;", serverManager.VirtualDirectoryDefaults.LogonMethod.ToString()); System.Console.WriteLine("\t\t应用程序池：&#123;0&#125;", serverManager.ApplicationDefaults.ApplicationPoolName); System.Console.WriteLine("\t\t自动启动：&#123;0&#125;", serverManager.SiteDefaults.ServerAutoStart); System.Console.WriteLine("\t行为："); System.Console.WriteLine("\t\t连接限制："); System.Console.WriteLine("\t\t\t连接超时（秒）：&#123;0&#125;", serverManager.SiteDefaults.Limits.ConnectionTimeout.TotalSeconds); System.Console.WriteLine("\t\t\t最大并发连接数：&#123;0&#125;", serverManager.SiteDefaults.Limits.MaxConnections); System.Console.WriteLine("\t\t\t最大带宽（字节/秒）：&#123;0&#125;", serverManager.SiteDefaults.Limits.MaxBandwidth); System.Console.WriteLine("\t\t失败请求跟踪："); System.Console.WriteLine("\t\t\t跟踪文件的最大数量：&#123;0&#125;", serverManager.SiteDefaults.TraceFailedRequestsLogging.MaxLogFiles); System.Console.WriteLine("\t\t\t目录：&#123;0&#125;", serverManager.SiteDefaults.TraceFailedRequestsLogging.Directory); System.Console.WriteLine("\t\t\t已启用：&#123;0&#125;", serverManager.SiteDefaults.TraceFailedRequestsLogging.Enabled); System.Console.WriteLine("\t\t已启用的协议：&#123;0&#125;", serverManager.ApplicationDefaults.EnabledProtocols); foreach (var s in serverManager.Sites)//遍历网站 &#123; System.Console.WriteLine(); System.Console.WriteLine("模式名：&#123;0&#125;", s.Schema.Name); System.Console.WriteLine("编号：&#123;0&#125;", s.Id); System.Console.WriteLine("网站名称：&#123;0&#125;", s.Name); System.Console.WriteLine("物理路径：&#123;0&#125;", s.Applications["/"].VirtualDirectories["/"].PhysicalPath); System.Console.WriteLine("物理路径凭据：&#123;0&#125;", s.Methods.ToString()); System.Console.WriteLine("应用程序池：&#123;0&#125;", s.Applications["/"].ApplicationPoolName); System.Console.WriteLine("已启用的协议：&#123;0&#125;", s.Applications["/"].EnabledProtocols); System.Console.WriteLine("自动启动：&#123;0&#125;", s.ServerAutoStart); System.Console.WriteLine("运行状态：&#123;0&#125;", s.State.ToString()); System.Console.WriteLine("网站绑定："); foreach (var tmp in s.Bindings) &#123; System.Console.WriteLine("\t类型：&#123;0&#125;", tmp.Protocol); //System.Console.WriteLine("\tIP 地址：&#123;0&#125;", tmp.EndPoint.Address.ToString()); //System.Console.WriteLine("\t端口：&#123;0&#125;", tmp.EndPoint.Port.ToString()); System.Console.WriteLine("\t主机名：&#123;0&#125;", tmp.Host); //System.Console.WriteLine(tmp.BindingInformation); //System.Console.WriteLine(tmp.CertificateStoreName); //System.Console.WriteLine(tmp.IsIPPortHostBinding); //System.Console.WriteLine(tmp.IsLocallyStored); //System.Console.WriteLine(tmp.UseDsMapper); &#125; System.Console.WriteLine("连接限制："); System.Console.WriteLine("\t连接超时（秒）：&#123;0&#125;", s.Limits.ConnectionTimeout.TotalSeconds); System.Console.WriteLine("\t最大并发连接数：&#123;0&#125;", s.Limits.MaxConnections); System.Console.WriteLine("\t最大带宽（字节/秒）：&#123;0&#125;", s.Limits.MaxBandwidth); System.Console.WriteLine("失败请求跟踪："); System.Console.WriteLine("\t跟踪文件的最大数量：&#123;0&#125;", s.TraceFailedRequestsLogging.MaxLogFiles); System.Console.WriteLine("\t目录：&#123;0&#125;", s.TraceFailedRequestsLogging.Directory); System.Console.WriteLine("\t已启用：&#123;0&#125;", s.TraceFailedRequestsLogging.Enabled); System.Console.WriteLine("日志："); //System.Console.WriteLine("\t启用日志服务：&#123;0&#125;", s.LogFile.Enabled); System.Console.WriteLine("\t格式：&#123;0&#125;", s.LogFile.LogFormat.ToString()); System.Console.WriteLine("\t目录：&#123;0&#125;", s.LogFile.Directory); System.Console.WriteLine("\t文件包含字段：&#123;0&#125;", s.LogFile.LogExtFileFlags.ToString()); System.Console.WriteLine("\t计划：&#123;0&#125;", s.LogFile.Period.ToString()); System.Console.WriteLine("\t最大文件大小（字节）：&#123;0&#125;", s.LogFile.TruncateSize); System.Console.WriteLine("\t使用本地时间进行文件命名和滚动更新：&#123;0&#125;", s.LogFile.LocalTimeRollover); System.Console.WriteLine("----应用程序的默认应用程序池：&#123;0&#125;", s.ApplicationDefaults.ApplicationPoolName); System.Console.WriteLine("----应用程序的默认已启用的协议：&#123;0&#125;", s.ApplicationDefaults.EnabledProtocols); //System.Console.WriteLine("----应用程序的默认物理路径凭据：&#123;0&#125;", s.ApplicationDefaults.Methods.ToString()); //System.Console.WriteLine("----虚拟目录的默认物理路径凭据：&#123;0&#125;", s.VirtualDirectoryDefaults.Methods.ToString()); System.Console.WriteLine("----虚拟目录的默认物理路径凭据登录类型：&#123;0&#125;", s.VirtualDirectoryDefaults.LogonMethod.ToString()); System.Console.WriteLine("----虚拟目录的默认用户名：&#123;0&#125;", s.VirtualDirectoryDefaults.UserName); System.Console.WriteLine("----虚拟目录的默认用户密码：&#123;0&#125;", s.VirtualDirectoryDefaults.Password); System.Console.WriteLine("应用程序 列表："); foreach (var tmp in s.Applications) &#123; if (tmp.Path != "/") &#123; System.Console.WriteLine("\t模式名：&#123;0&#125;", tmp.Schema.Name); System.Console.WriteLine("\t虚拟路径：&#123;0&#125;", tmp.Path); System.Console.WriteLine("\t物理路径：&#123;0&#125;", tmp.VirtualDirectories["/"].PhysicalPath); //System.Console.WriteLine("\t物理路径凭据：&#123;0&#125;", tmp.Methods.ToString()); System.Console.WriteLine("\t应用程序池：&#123;0&#125;", tmp.ApplicationPoolName); System.Console.WriteLine("\t已启用的协议：&#123;0&#125;", tmp.EnabledProtocols); &#125; System.Console.WriteLine("\t虚拟目录 列表："); foreach (var tmp2 in tmp.VirtualDirectories) &#123; if (tmp2.Path != "/") &#123; System.Console.WriteLine("\t\t模式名：&#123;0&#125;", tmp2.Schema.Name); System.Console.WriteLine("\t\t虚拟路径：&#123;0&#125;", tmp2.Path); System.Console.WriteLine("\t\t物理路径：&#123;0&#125;", tmp2.PhysicalPath); //System.Console.WriteLine("\t\t物理路径凭据：&#123;0&#125;", tmp2.Methods.ToString()); System.Console.WriteLine("\t\t物理路径凭据登录类型：&#123;0&#125;", tmp2.LogonMethod.ToString()); &#125; &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 获得可用端口号 /// &lt;/summary&gt; /// &lt;param name="ports"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetFreePort(ref ArrayList ports) &#123; ////1024－49151 string result = ""; for (int i = 1024; i &lt; 49151; i++) &#123; if (!ports.Contains(i)) &#123; ports.Add(i); result = i.ToString(); break; &#125; &#125; return result; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763using System;using System.Text;using System.IO;namespace CommonTools&#123; /// &lt;summary&gt; /// 文件操作夹 /// &lt;/summary&gt; public static class DirFileHelper &#123; #region 检测指定目录是否存在 /// &lt;summary&gt; /// 检测指定目录是否存在 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;目录的绝对路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsExistDirectory(string directoryPath) &#123; return Directory.Exists(directoryPath); &#125; #endregion #region 检测指定文件是否存在,如果存在返回true /// &lt;summary&gt; /// 检测指定文件是否存在,如果存在则返回true。 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static bool IsExistFile(string filePath) &#123; return File.Exists(filePath); &#125; #endregion #region 获取指定目录中的文件列表 /// &lt;summary&gt; /// 获取指定目录中所有文件列表 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static string[] GetFileNames(string directoryPath) &#123; //如果目录不存在，则抛出异常 if (!IsExistDirectory(directoryPath)) &#123; throw new FileNotFoundException(); &#125; //获取文件列表 return Directory.GetFiles(directoryPath); &#125; #endregion #region 获取指定目录中所有子目录列表,若要搜索嵌套的子目录列表,请使用重载方法. /// &lt;summary&gt; /// 获取指定目录中所有子目录列表,若要搜索嵌套的子目录列表,请使用重载方法. /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static string[] GetDirectories(string directoryPath) &#123; try &#123; return Directory.GetDirectories(directoryPath); &#125; catch (IOException ex) &#123; throw ex; &#125; &#125; #endregion #region 获取指定目录及子目录中所有文件列表 /// &lt;summary&gt; /// 获取指定目录及子目录中所有文件列表 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; /// &lt;param name="isSearchChild"&gt;是否搜索子目录&lt;/param&gt; public static string[] GetFileNames(string directoryPath, string searchPattern, bool isSearchChild) &#123; //如果目录不存在，则抛出异常 if (!IsExistDirectory(directoryPath)) &#123; throw new FileNotFoundException(); &#125; try &#123; if (isSearchChild) &#123; return Directory.GetFiles(directoryPath, searchPattern, SearchOption.AllDirectories); &#125; else &#123; return Directory.GetFiles(directoryPath, searchPattern, SearchOption.TopDirectoryOnly); &#125; &#125; catch (IOException ex) &#123; throw ex; &#125; &#125; #endregion #region 检测指定目录是否为空 /// &lt;summary&gt; /// 检测指定目录是否为空 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static bool IsEmptyDirectory(string directoryPath) &#123; try &#123; //判断是否存在文件 string[] fileNames = GetFileNames(directoryPath); if (fileNames.Length &gt; 0) &#123; return false; &#125; //判断是否存在文件夹 string[] directoryNames = GetDirectories(directoryPath); if (directoryNames.Length &gt; 0) &#123; return false; &#125; return true; &#125; catch &#123; //这里记录日志 //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); return true; &#125; &#125; #endregion #region 检测指定目录中是否存在指定的文件 /// &lt;summary&gt; /// 检测指定目录中是否存在指定的文件,若要搜索子目录请使用重载方法. /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; public static bool Contains(string directoryPath, string searchPattern) &#123; try &#123; //获取指定的文件列表 string[] fileNames = GetFileNames(directoryPath, searchPattern, false); //判断指定文件是否存在 if (fileNames.Length == 0) &#123; return false; &#125; else &#123; return true; &#125; &#125; catch (Exception ex) &#123; throw new Exception(ex.Message); //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); &#125; &#125; /// &lt;summary&gt; /// 检测指定目录中是否存在指定的文件 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; /// &lt;param name="isSearchChild"&gt;是否搜索子目录&lt;/param&gt; public static bool Contains(string directoryPath, string searchPattern, bool isSearchChild) &#123; try &#123; //获取指定的文件列表 string[] fileNames = GetFileNames(directoryPath, searchPattern, true); //判断指定文件是否存在 if (fileNames.Length == 0) &#123; return false; &#125; else &#123; return true; &#125; &#125; catch (Exception ex) &#123; throw new Exception(ex.Message); //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); &#125; &#125; #endregion #region 创建目录 /// &lt;summary&gt; /// 创建目录 /// &lt;/summary&gt; /// &lt;param name="dir"&gt;要创建的目录路径包括目录名&lt;/param&gt; public static void CreateDir(string dir) &#123; if (dir.Length == 0) return; if (!Directory.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir)) Directory.CreateDirectory(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir); &#125; #endregion #region 删除目录 /// &lt;summary&gt; /// 删除目录 /// &lt;/summary&gt; /// &lt;param name="dir"&gt;要删除的目录路径和名称&lt;/param&gt; public static void DeleteDir(string dir) &#123; if (dir.Length == 0) return; if (Directory.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir)) Directory.Delete(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir); &#125; #endregion #region 删除文件 /// &lt;summary&gt; /// 删除文件 /// &lt;/summary&gt; /// &lt;param name="file"&gt;要删除的文件路径和名称&lt;/param&gt; public static void DeleteFile(string file) &#123; if (File.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + file)) File.Delete(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + file); &#125; #endregion #region 创建文件 /// &lt;summary&gt; /// 创建文件 /// &lt;/summary&gt; /// &lt;param name="dir"&gt;带后缀的文件名&lt;/param&gt; /// &lt;param name="pagestr"&gt;文件内容&lt;/param&gt; public static void CreateFile(string dir, string pagestr) &#123; dir = dir.Replace("/", "\\"); if (dir.IndexOf("\\") &gt; -1) CreateDir(dir.Substring(0, dir.LastIndexOf("\\"))); System.IO.StreamWriter sw = new System.IO.StreamWriter(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir, false, System.Text.Encoding.GetEncoding("GB2312")); sw.Write(pagestr); sw.Close(); &#125; #endregion #region 移动文件(剪贴--粘贴) /// &lt;summary&gt; /// 移动文件(剪贴--粘贴) /// &lt;/summary&gt; /// &lt;param name="dir1"&gt;要移动的文件的路径及全名(包括后缀)&lt;/param&gt; /// &lt;param name="dir2"&gt;文件移动到新的位置,并指定新的文件名&lt;/param&gt; public static void MoveFile(string dir1, string dir2) &#123; dir1 = dir1.Replace("/", "\\"); dir2 = dir2.Replace("/", "\\"); if (File.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1)) File.Move(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1, System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir2); &#125; #endregion #region 复制文件 /// &lt;summary&gt; /// 复制文件 /// &lt;/summary&gt; /// &lt;param name="dir1"&gt;要复制的文件的路径已经全名(包括后缀)&lt;/param&gt; /// &lt;param name="dir2"&gt;目标位置,并指定新的文件名&lt;/param&gt; public static void CopyFile(string dir1, string dir2) &#123; dir1 = dir1.Replace("/", "\\"); dir2 = dir2.Replace("/", "\\"); if (File.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1)) &#123; File.Copy(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1, System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir2, true); &#125; &#125; #endregion #region 根据时间得到目录名 / 格式:yyyyMMdd 或者 HHmmssff /// &lt;summary&gt; /// 根据时间得到目录名yyyyMMdd /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetDateDir() &#123; return DateTime.Now.ToString("yyyyMMdd"); &#125; /// &lt;summary&gt; /// 根据时间得到文件名HHmmssff /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetDateFile() &#123; return DateTime.Now.ToString("HHmmssff"); &#125; #endregion #region 复制文件夹 /// &lt;summary&gt; /// 复制文件夹(递归) /// &lt;/summary&gt; /// &lt;param name="varFromDirectory"&gt;源文件夹路径&lt;/param&gt; /// &lt;param name="varToDirectory"&gt;目标文件夹路径&lt;/param&gt; public static void CopyFolder(string varFromDirectory, string varToDirectory) &#123; Directory.CreateDirectory(varToDirectory); if (!Directory.Exists(varFromDirectory)) return; string[] directories = Directory.GetDirectories(varFromDirectory); if (directories.Length &gt; 0) &#123; foreach (string d in directories) &#123; CopyFolder(d, varToDirectory + d.Substring(d.LastIndexOf("\\"))); &#125; &#125; string[] files = Directory.GetFiles(varFromDirectory); if (files.Length &gt; 0) &#123; foreach (string s in files) &#123; File.Copy(s, varToDirectory + s.Substring(s.LastIndexOf("\\")), true); &#125; &#125; &#125; #endregion #region 检查文件,如果文件不存在则创建 /// &lt;summary&gt; /// 检查文件,如果文件不存在则创建 /// &lt;/summary&gt; /// &lt;param name="FilePath"&gt;路径,包括文件名&lt;/param&gt; public static void ExistsFile(string FilePath) &#123; //if(!File.Exists(FilePath)) //File.Create(FilePath); //以上写法会报错,详细解释请看下文......... if (!File.Exists(FilePath)) &#123; FileStream fs = File.Create(FilePath); fs.Close(); &#125; &#125; #endregion #region 删除指定文件夹对应其他文件夹里的文件 /// &lt;summary&gt; /// 删除指定文件夹对应其他文件夹里的文件 /// &lt;/summary&gt; /// &lt;param name="varFromDirectory"&gt;指定文件夹路径&lt;/param&gt; /// &lt;param name="varToDirectory"&gt;对应其他文件夹路径&lt;/param&gt; public static void DeleteFolderFiles(string varFromDirectory, string varToDirectory) &#123; Directory.CreateDirectory(varToDirectory); if (!Directory.Exists(varFromDirectory)) return; string[] directories = Directory.GetDirectories(varFromDirectory); if (directories.Length &gt; 0) &#123; foreach (string d in directories) &#123; DeleteFolderFiles(d, varToDirectory + d.Substring(d.LastIndexOf("\\"))); &#125; &#125; string[] files = Directory.GetFiles(varFromDirectory); if (files.Length &gt; 0) &#123; foreach (string s in files) &#123; File.Delete(varToDirectory + s.Substring(s.LastIndexOf("\\"))); &#125; &#125; &#125; #endregion #region 从文件的绝对路径中获取文件名( 包含扩展名 ) /// &lt;summary&gt; /// 从文件的绝对路径中获取文件名( 包含扩展名 ) /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static string GetFileName(string filePath) &#123; //获取文件的名称 FileInfo fi = new FileInfo(filePath); return fi.Name; &#125; #endregion /// &lt;summary&gt; /// 复制文件参考方法,页面中引用 /// &lt;/summary&gt; /// &lt;param name="cDir"&gt;新路径&lt;/param&gt; /// &lt;param name="TempId"&gt;模板引擎替换编号&lt;/param&gt; public static void CopyFiles(string cDir, string TempId) &#123; //if (Directory.Exists(Request.PhysicalApplicationPath + "\\Controls")) //&#123; // string TempStr = string.Empty; // StreamWriter sw; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Default.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Default.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Default.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Column.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Column.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\List.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Content.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Content.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\View.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\MoreDiss.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\MoreDiss.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\DissList.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\ShowDiss.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\ShowDiss.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Diss.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Review.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Review.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Review.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Search.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Search.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Search.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; //&#125; &#125; #region 创建一个目录 /// &lt;summary&gt; /// 创建一个目录 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;目录的绝对路径&lt;/param&gt; public static void CreateDirectory(string directoryPath) &#123; //如果目录不存在则创建该目录 if (!IsExistDirectory(directoryPath)) &#123; Directory.CreateDirectory(directoryPath); &#125; &#125; #endregion #region 创建一个文件 /// &lt;summary&gt; /// 创建一个文件。 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static void CreateFile(string filePath) &#123; try &#123; //如果文件不存在则创建该文件 if (!IsExistFile(filePath)) &#123; //创建一个FileInfo对象 FileInfo file = new FileInfo(filePath); //创建文件 FileStream fs = file.Create(); //关闭文件流 fs.Close(); &#125; &#125; catch (Exception ex) &#123; //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); throw ex; &#125; &#125; /// &lt;summary&gt; /// 创建一个文件,并将字节流写入文件。 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; /// &lt;param name="buffer"&gt;二进制流数据&lt;/param&gt; public static void CreateFile(string filePath, byte[] buffer) &#123; try &#123; //如果文件不存在则创建该文件 if (!IsExistFile(filePath)) &#123; //创建一个FileInfo对象 FileInfo file = new FileInfo(filePath); //创建文件 FileStream fs = file.Create(); //写入二进制流 fs.Write(buffer, 0, buffer.Length); //关闭文件流 fs.Close(); &#125; &#125; catch (Exception ex) &#123; //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); throw ex; &#125; &#125; #endregion #region 获取文本文件的行数 /// &lt;summary&gt; /// 获取文本文件的行数 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static int GetLineCount(string filePath) &#123; //将文本文件的各行读到一个字符串数组中 string[] rows = File.ReadAllLines(filePath); //返回行数 return rows.Length; &#125; #endregion #region 获取一个文件的长度 /// &lt;summary&gt; /// 获取一个文件的长度,单位为Byte /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static int GetFileSize(string filePath) &#123; //创建一个文件对象 FileInfo fi = new FileInfo(filePath); //获取文件的大小 return (int)fi.Length; &#125; #endregion #region 获取指定目录中的子目录列表 /// &lt;summary&gt; /// 获取指定目录及子目录中所有子目录列表 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; /// &lt;param name="isSearchChild"&gt;是否搜索子目录&lt;/param&gt; public static string[] GetDirectories(string directoryPath, string searchPattern, bool isSearchChild) &#123; try &#123; if (isSearchChild) &#123; return Directory.GetDirectories(directoryPath, searchPattern, SearchOption.AllDirectories); &#125; else &#123; return Directory.GetDirectories(directoryPath, searchPattern, SearchOption.TopDirectoryOnly); &#125; &#125; catch (IOException ex) &#123; throw ex; &#125; &#125; #endregion #region 向文本文件写入内容 /// &lt;summary&gt; /// 向文本文件中写入内容 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; /// &lt;param name="text"&gt;写入的内容&lt;/param&gt; /// &lt;param name="encoding"&gt;编码&lt;/param&gt; public static void WriteText(string filePath, string text, Encoding encoding) &#123; //向文件写入内容 File.WriteAllText(filePath, text, encoding); &#125; #endregion #region 向文本文件的尾部追加内容 /// &lt;summary&gt; /// 向文本文件的尾部追加内容 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; /// &lt;param name="content"&gt;写入的内容&lt;/param&gt; public static void AppendText(string filePath, string content) &#123; File.AppendAllText(filePath, content); &#125; #endregion #region 将现有文件的内容复制到新文件中 /// &lt;summary&gt; /// 将源文件的内容复制到目标文件中 /// &lt;/summary&gt; /// &lt;param name="sourceFilePath"&gt;源文件的绝对路径&lt;/param&gt; /// &lt;param name="destFilePath"&gt;目标文件的绝对路径&lt;/param&gt; public static void Copy(string sourceFilePath, string destFilePath) &#123; File.Copy(sourceFilePath, destFilePath, true); &#125; #endregion #region 将文件移动到指定目录 /// &lt;summary&gt; /// 将文件移动到指定目录 /// &lt;/summary&gt; /// &lt;param name="sourceFilePath"&gt;需要移动的源文件的绝对路径&lt;/param&gt; /// &lt;param name="descDirectoryPath"&gt;移动到的目录的绝对路径&lt;/param&gt; public static void Move(string sourceFilePath, string descDirectoryPath) &#123; //获取源文件的名称 string sourceFileName = GetFileName(sourceFilePath); if (IsExistDirectory(descDirectoryPath)) &#123; //如果目标中存在同名文件,则删除 if (IsExistFile(descDirectoryPath + "\\" + sourceFileName)) &#123; DeleteFile(descDirectoryPath + "\\" + sourceFileName); &#125; //将文件移动到指定目录 File.Move(sourceFilePath, descDirectoryPath + "\\" + sourceFileName); &#125; &#125; #endregion #region 从文件的绝对路径中获取文件名( 不包含扩展名 ) /// &lt;summary&gt; /// 从文件的绝对路径中获取文件名( 不包含扩展名 ) /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static string GetFileNameNoExtension(string filePath) &#123; //获取文件的名称 FileInfo fi = new FileInfo(filePath); return fi.Name.Split('.')[0]; &#125; #endregion #region 从文件的绝对路径中获取扩展名 /// &lt;summary&gt; /// 从文件的绝对路径中获取扩展名 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static string GetExtension(string filePath) &#123; //获取文件的名称 FileInfo fi = new FileInfo(filePath); return fi.Extension; &#125; #endregion #region 清空指定目录 /// &lt;summary&gt; /// 清空指定目录下所有文件及子目录,但该目录依然保存. /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static void ClearDirectory(string directoryPath) &#123; if (IsExistDirectory(directoryPath)) &#123; //删除目录中所有的文件 string[] fileNames = GetFileNames(directoryPath); for (int i = 0; i &lt; fileNames.Length; i++) &#123; DeleteFile(fileNames[i]); &#125; //删除目录中所有的子目录 string[] directoryNames = GetDirectories(directoryPath); for (int i = 0; i &lt; directoryNames.Length; i++) &#123; DeleteDirectory(directoryNames[i]); &#125; &#125; &#125; #endregion #region 清空文件内容 /// &lt;summary&gt; /// 清空文件内容 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static void ClearFile(string filePath) &#123; //删除文件 File.Delete(filePath); //重新创建该文件 CreateFile(filePath); &#125; #endregion #region 删除指定目录 /// &lt;summary&gt; /// 删除指定目录及其所有子目录 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static void DeleteDirectory(string directoryPath) &#123; if (IsExistDirectory(directoryPath)) &#123; Directory.Delete(directoryPath, true); &#125; &#125; #endregion &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.Net</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.net获得本机可用端口号]]></title>
    <url>%2F2017%2F06%2F19%2Fnet%E8%8E%B7%E5%BE%97%E6%9C%AC%E6%9C%BA%E5%8F%AF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[好久没有总结文字了，上周整理过一个IIS自动发布并绑定域名的demo，其中有一部分需要读取未使用的服务器端口号用来发布网站，因此整理出该方法。实现逻辑思路：.net 通过命令提示符窗口获得当前已用端口，再筛选出可用端口。 公用方法代码12345678910111213141516171819202122232425262728293031323334353637383940414243public string GetFreePort() &#123; string result = ""; Process p = new Process(); p.StartInfo.FileName = "cmd.exe";//设置启动的应用程序 p.StartInfo.UseShellExecute = false;//禁止使用操作系统外壳程序启动进程 p.StartInfo.RedirectStandardInput = true;//应用程序的输入从流中读取 p.StartInfo.RedirectStandardOutput = true;//应用程序的输出写入流中 p.StartInfo.RedirectStandardError = true;//将错误信息写入流 p.StartInfo.CreateNoWindow = true;//是否在新窗口中启动进程 p.Start(); //p.StandardInput.WriteLine(@"netstat -a -n&gt;c:\port.txt");//将字符串写入文本流 p.StandardInput.WriteLine(@"netstat -a -n"); p.StandardInput.WriteLine("exit"); //此处必须加退出命令，否则界面会卡死在cmd窗口无法继续执行 string str; StreamReader reader=p.StandardOutput; str = reader.ReadLine(); ArrayList ports = new ArrayList(); ////匹配出端口号 string pattern = @":\d+"; //正则表达式字符串 Regex regex = new Regex(pattern); while (!reader.EndOfStream) &#123; Match match = regex.Match(str); if (match.Success) &#123; string port = match.Groups[0].Value.Substring(1); ports.Add(port); &#125; Console.WriteLine(str); str = reader.ReadLine(); &#125; ////可用端口号范围1024－49151 for (int i = 1024; i &lt; 49151; i++) &#123; if (!ports.Contains(i)) &#123; result = i.ToString(); break; &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window服务守护外部程序不被关闭]]></title>
    <url>%2F2017%2F01%2F21%2Fwindow%E6%9C%8D%E5%8A%A1%E5%AE%88%E6%8A%A4%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、需求描述：保证程序能够一直运行，不会关闭。2、实现过程：创建windows服务并保持自动运行，该服务定时检查程序进程是否关闭，如果关闭则启动。3、实现过程中遇到的问题：windows服务直接打开外部程序，该程序只存在于任务管理器中的进程中，界面无法直接显示。 服务定时访问代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public partial class Service1 : ServiceBase &#123; private System.Timers.Timer aTimer;//定时器 public Service1() &#123; InitializeComponent(); &#125; protected override void OnStart(string[] args) &#123; // As creating a child process might be a time consuming operation, // its better to do that in a separate thread than blocking the main thread. //System.Threading.Thread ProcessCreationThread = new System.Threading.Thread(MyThreadFunc); //ProcessCreationThread.Start(); MyThreadFunc(); &#125; // This thread function would launch a child process // in the interactive session of the logged-on user. public void MyThreadFunc() &#123; Log.WriteLogToTxt(&quot;打开多屏系统&quot;); aTimer = new System.Timers.Timer(); //第一次马上打开 timer1_Tick(null,null); //到达时间的时候执行事件； aTimer.Elapsed += new ElapsedEventHandler(timer1_Tick); // 设置引发时间的时间间隔 此处设置为1秒（1000毫秒） aTimer.Interval = Convert.ToDouble(AppConfig.GetApp(&quot;INTERVAL&quot;)); //设置是执行一次（false）还是一直执行(true)； aTimer.AutoReset = true; //是否执行System.Timers.Timer.Elapsed事件； aTimer.Enabled = true; aTimer.Start(); &#125; /// &lt;summary&gt; /// 定时事件 /// &lt;/summary&gt; /// &lt;param name=&quot;source&quot;&gt;源对象&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;ElapsedEventArgs事件对象&lt;/param&gt; protected void timer1_Tick(object source, ElapsedEventArgs e) &#123; bool isProcessResult = IsProcessStarted(&quot;IocpServer&quot;);//判断是否运行 if (!isProcessResult) &#123; //Debugger.Launch();调试debug Log.WriteLogToTxt(&quot;自动开始运行&quot;); //此处可以直接将exe运行地址赋值如c:\1.exe string applicationLocation = AppConfig.GetApp(&quot;ApplicationLocation&quot;); Log.WriteLogToTxt(applicationLocation); CreateProcessAsUserWrapper.LaunchChildProcess(applicationLocation); &#125; &#125; private void myprocess_Exited(object sender, EventArgs e)//被触发的程序 &#123; Log.WriteLogToTxt(&quot;关闭多屏系统&quot;); &#125; /// &lt;summary&gt; /// 判断程序是否运行 /// &lt;/summary&gt; /// &lt;param name=&quot;processName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private bool IsProcessStarted(string processName) &#123; Process[] temp = Process.GetProcessesByName(processName); if (temp.Length &gt; 0) &#123; string tempName = &quot;&quot;; foreach (Process process in temp) &#123; tempName += process.ProcessName + &quot;;&quot;; &#125; //Log.WriteLogToTxt(&quot;程序名称&quot; + tempName); return true; &#125; else &#123; return false; &#125; &#125; protected override void OnStop() &#123; &#125; &#125; 微软demo]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>WinForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周日历实现]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%91%A8%E6%97%A5%E5%8E%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[要实现的功能：通过点击或拖动选择在日历中根据时间段列出的课程单元格。该Table可用的功能包括：1、按周来显示的日历；2、可拖动、点击选择表格；3、可用来设置日程、课程相关table原型；遇到的坑：1、js对象使用地址引用来传递，导致循环获得moment时间对象的值放到数组中后，全部相同且是最后一个，最后使用new moment()，重新再创建一个对象来解决。12345var today=new moment();var array=new Array();for(var i=0;i&lt;3;i++)&#123; array.push(new moment(today.add(1,&quot;days&quot;)));//添加一天 解决地址传递 &#125; 源码及演示]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态调用webservice]]></title>
    <url>%2F2016%2F12%2F24%2F%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8webservice%2F</url>
    <content type="text"><![CDATA[关于webservice的调用方法 之前使用或了解的只是通过vs的操作界面直接引入web服务而调用的，现在才知道调用的方式也可以使用反射的机制来实现， 网上找到的代码本地测试可以使用，留存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Web.Services.Description;using System.CodeDom;using Microsoft.CSharp;using System.CodeDom.Compiler;using System.Net;using System.IO;namespace DirectInvoke&#123; class Program &#123; static void Main(string[] args) &#123; string serviceUrl = "http://www.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx"; object o = Webservice.InvokeWebService(serviceUrl, "getSupportProvince", new object[] &#123; &#125;); &#125; //反射获得方法及成员 public void PrintInstanceInfor(Type t) &#123; //获取所有方法 System.Reflection.MethodInfo[] methods = t.GetMethods(); //获取所有成员 System.Reflection.MemberInfo[] members = t.GetMembers(); //获取所有属性 System.Reflection.PropertyInfo[] properties = t.GetProperties(); &#125; &#125; public class Webservice &#123; /// &lt;summary&gt; /// 实例化WebServices /// &lt;/summary&gt; /// &lt;param name="url"&gt;WebServices地址&lt;/param&gt; /// &lt;param name="methodname"&gt;调用的方法&lt;/param&gt; /// &lt;param name="args"&gt;把webservices里需要的参数按顺序放到这个object[]里&lt;/param&gt; public static object InvokeWebService(string url, string methodname, object[] args) &#123; //这里的namespace是需引用的webservices的命名空间，我没有改过，也可以使用。也可以加一个参数从外面传进来。 string @namespace = "client"; try &#123; //获取WSDL WebClient wc = new WebClient(); Stream stream = wc.OpenRead(url + "?WSDL"); ServiceDescription sd = ServiceDescription.Read(stream); string classname = sd.Services[0].Name; ServiceDescriptionImporter sdi = new ServiceDescriptionImporter(); sdi.AddServiceDescription(sd, "", ""); CodeNamespace cn = new CodeNamespace(@namespace); //生成客户端代理类代码 CodeCompileUnit ccu = new CodeCompileUnit(); ccu.Namespaces.Add(cn); sdi.Import(cn, ccu); CSharpCodeProvider csc = new CSharpCodeProvider(); //ICodeCompiler icc = csc.CreateCompiler(); //设定编译参数 CompilerParameters cplist = new CompilerParameters(); cplist.GenerateExecutable = false; cplist.GenerateInMemory = true; cplist.ReferencedAssemblies.Add("System.dll"); cplist.ReferencedAssemblies.Add("System.xml.dll"); cplist.ReferencedAssemblies.Add("System.Web.Services.dll"); cplist.ReferencedAssemblies.Add("System.Data.dll"); //编译代理类 CompilerResults cr = csc.CompileAssemblyFromDom(cplist, ccu); if (true == cr.Errors.HasErrors) &#123; System.Text.StringBuilder sb = new System.Text.StringBuilder(); foreach (System.CodeDom.Compiler.CompilerError ce in cr.Errors) &#123; sb.Append(ce.ToString()); sb.Append(System.Environment.NewLine); &#125; throw new Exception(sb.ToString()); &#125; //生成代理实例，并调用方法 System.Reflection.Assembly assembly = cr.CompiledAssembly; Type t = assembly.GetType(@namespace + "." + classname, true, true); object obj = Activator.CreateInstance(t); System.Reflection.MethodInfo mi = t.GetMethod(methodname); return mi.Invoke(obj, args); &#125; catch &#123; return null; &#125; &#125; &#125;&#125; 核心代码转自]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>c#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS动态创建行]]></title>
    <url>%2F2016%2F12%2F02%2FJS%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[JS在前台动态创建表格行，行的数量按照用户来定，行内有select下拉框、文本框或者是easyui-combobox组合框。文本框增加数字验证。需要做如图的报表 1、js代码1234567891011121314151617181920212223242526//添加空行 function addRow() &#123; var rowNum = $(".firmRow").length; //增加第一行 var $newRow = $(".firmRow:first").clone(); $newRow.removeClass("hideFirmRow"); //修改名称// $newRow.find("select").attr("name", "cFirmGuid" + rowNum); //普通select下拉框 //easyui-combobox组合框控件 $newRow.find("td:eq(0)").html("&lt;select class='easyui-combobox' name='cFirmGuid" + rowNum + "' style='width:100%;'&gt;&lt;/select&gt;"); $newRow.find("input:eq(0)").attr("name", "cContactAdd" + rowNum); $newRow.find("input:eq(1)").attr("name", "cIllegality" + rowNum); $newRow.find("input:eq(2)").attr("name", "iIssueNum" + rowNum); $newRow.find("input:eq(3)").attr("name", "cSituation" + rowNum); $("#JDJLK").before($newRow); $newRow.find(".easyui-combobox").combobox(&#123; valueField: 'cEnterpriseGUID', textField: 'cEnterpriseName', data: res, onChange: function (newValue, oldValue) &#123; //获得企业地址 changeEnterprise(newValue, rowNum);//修改下拉框值后，触发事件 &#125; &#125;); &#125; 2、HTML代码12345678910111213141516171819202122&lt;table&gt;&lt;tr class="firmRow hideFirmRow"&gt; &lt;td colspan="2"&gt; &lt;select class="easyui-combobox" style="width:100%;"&gt; &lt;/select&gt; &lt;/td&gt; &lt;td colspan="2"&gt; &lt;asp:TextBox runat="server" /&gt; &lt;/td&gt; &lt;td colspan="4"&gt; &lt;asp:TextBox runat="server" /&gt; &lt;/td&gt; &lt;td&gt; &lt;asp:TextBox runat="server" onkeyup="if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,'')&#125;else&#123;this.value=this.value.replace(/\D/g,'')&#125;" onafterpaste="if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,'')&#125;else&#123;this.value=this.value.replace(/\D/g,'')&#125;" /&gt; &lt;/td&gt; &lt;td colspan="3"&gt; &lt;asp:TextBox runat="server" /&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 3、firmRow表示是第一行，hideFirmRow用来将第一行隐藏当需要创建行时，直接使用jquery的Clone，将firmRow克隆然后设置值就好了，方便操作。1var $newRow = $(&quot;.firmRow:first&quot;).clone(); 4、其中文本控件增加了JS验证，只能输入数字12&lt;asp:TextBox runat=&quot;server&quot; onkeyup=&quot;if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,&apos;&apos;)&#125;else&#123;this.value=this.value.replace(/\D/g,&apos;&apos;)&#125;&quot;onafterpaste=&quot;if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,&apos;&apos;)&#125;else&#123;this.value=this.value.replace(/\D/g,&apos;&apos;)&#125;&quot; /&gt; 5、easyui-combobox 绑定初始化12345 $(&quot;.easyui-combobox&quot;).combobox(&#123;valueField: &apos;值列名&apos;,textField: &apos;文本列名&apos;,data: res //res是JSON对象 &#125;);]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>easyui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.Net 文件上传大小限制]]></title>
    <url>%2F2016%2F11%2F15%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、主要有两个地方需要配置，httpRuntime节点 maxRequestLength 最大请求长度 byterequestLimits节点 maxAllowedContentLength 最大上传文件长度 byte这两个值需要设置为一致，IIS7 最大支持2GB 即2147483647B 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;connectionStrings configSource="XmlConfig\database.config" /&gt; &lt;appSettings configSource="XmlConfig\system.config" /&gt; &lt;system.web&gt; &lt;!-- 文件上传 允许请求的最大长度 单位byte 默认4096KB--&gt; &lt;httpRuntime requestValidationMode="2.0" requestLengthDiskThreshold="256" maxRequestLength="2147483647" executionTimeout="1800"/&gt; &lt;/system.web&gt; &lt;system.webServer&gt; &lt;modules runAllManagedModulesForAllRequests="true" /&gt; &lt;security&gt; &lt;requestFiltering&gt; &lt;!--上传文件大小限制单位字节 byte 最大不超过2G--&gt; &lt;requestLimits maxQueryString="2147483647" maxAllowedContentLength="2147483647"/&gt; &lt;/requestFiltering&gt; &lt;/security&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FireFox右键菜单兼容]]></title>
    <url>%2F2016%2F10%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Firefox Event与 IE window Event兼容 在系统开发中，需要用户操作鼠标右键打开菜单时，IE直接通过使用window.event来获得对象的事件而火狐浏览器则使用触发方法中的event来获得，为了同时兼容，最后需要标准化事件对象。即：var evt=evt || event123456789101112131415&lt;script&gt; $(function()&#123; $(element).bind(&quot;contextmenu&quot;, function (evt) &#123; //设置弹出框对象高度宽度 //获取的这个ID为obj的DIV对象就是个实例引起鼠标事件的元素 //evt代表事件对象（W3C DOM标准下） var evt=evt || event; //标准化事件对象（W3C DOM 和IE DOM ） evt.Target=evt.Target || evt.srcElement;//标准化事件对象属性&lt;引起事件的元素&gt; //（W3C DOM 和IE DOM ） evt.layerX=evt.layerX || evt.offsetX;//鼠标相对于引起事件的元素的父元素的X坐标(标准化IE) evt.layerY=evt.layerY || evt.offsetY;//鼠标相对于引起事件的元素的父元素的Y坐标(标准化IE) alert(&quot;相对这个DIV的X方向的坐标&quot;+evt.layerX+&quot;\n相对这个DIV的Y方向的坐标&quot;+evt.layerY) &#125; &#125;);&lt;/script&gt; 123456789101112131415//自定义右键菜单 jQuery(tabControl_tab_ul).bind(&quot;contextmenu&quot;, function (e) &#123; var event = e || window.event;//e表示火狐事件，window.event表示chrome或IE事件 var oMenu = jQuery(&apos;.rightMenu&apos;);//右键要显示的菜单 oMenu.show(); oMenu.css(&apos;top&apos;, event.clientY + &quot;px&quot;); oMenu.css(&apos;left&apos;, event.clientX + &quot;px&quot;); window.setTimeout(function () &#123; oMenu.hide();//延时2秒后自动关闭 &#125;, 10000); return false; &#125;).bind(&quot;click&quot;, function () &#123; oMenu.hide();//单击后关闭 &#125;);]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZIP压缩.Net与Android相互解压]]></title>
    <url>%2F2016%2F09%2F28%2FZIP%E5%8E%8B%E7%BC%A9-Net%E4%B8%8EAndroid%E7%9B%B8%E4%BA%92%E8%A7%A3%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[使用.NET搭建webservice，使用JAVA在Android端接受 .Net与JAVA互相通过ZIP压缩协议进行压缩和解压字符串，减少传输字节量，加快传输速度增加用户友好。Android123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.example.administrator.myapplication;import android.util.Base64;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * Created by Administrator on 2016/9/15. */public class GZIP &#123; public static byte[] compress(String string) throws IOException &#123; ByteArrayOutputStream os = new ByteArrayOutputStream(string.length()); GZIPOutputStream gos = new GZIPOutputStream(os); gos.write(string.getBytes()); gos.close(); byte[] compressed = os.toByteArray(); os.close(); return compressed; &#125; public static String decompress(byte[] compressed) throws IOException &#123; final int BUFFER_SIZE = 32; ByteArrayInputStream is = new ByteArrayInputStream(compressed); GZIPInputStream gis = new GZIPInputStream(is, BUFFER_SIZE); StringBuilder string = new StringBuilder(); byte[] data = new byte[BUFFER_SIZE]; int bytesRead; while ((bytesRead = gis.read(data)) != -1) &#123; string.append(new String(data, 0, bytesRead)); &#125; gis.close(); is.close(); return string.toString(); &#125; public static String compress1(String str) throws IOException &#123; byte[] data=str.getBytes("UTF-8"); byte[] blockcopy = ByteBuffer .allocate(4) .order(java.nio.ByteOrder.LITTLE_ENDIAN) .putInt(data.length) .array(); ByteArrayOutputStream os = new ByteArrayOutputStream(data.length);// os.write(new byte[]&#123;0x05, 0, 0, 0&#125;,0,4); GZIPOutputStream gos = new GZIPOutputStream(os); gos.write(data); gos.close(); os.close(); byte[] compressed = new byte[4 + os.toByteArray().length]; System.arraycopy(blockcopy, 0, compressed, 0, 4); System.arraycopy(os.toByteArray(), 0, compressed, 4, os.toByteArray().length); byte[] result1= Base64.encode(compressed,Base64.DEFAULT); return new String (result1); &#125; public static String decompress1(String zipText) throws IOException &#123; byte[] compressed = Base64.decode(zipText,Base64.DEFAULT); if (compressed.length &gt; 4) &#123; GZIPInputStream gzipInputStream = new GZIPInputStream( new ByteArrayInputStream(compressed, 4, compressed.length - 4)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); for (int value = 0; value != -1;) &#123; value = gzipInputStream.read(); if (value != -1) &#123; baos.write(value); &#125; &#125; gzipInputStream.close(); baos.close(); String sReturn = new String(baos.toByteArray(), "UTF-8"); return sReturn; &#125; else &#123; return ""; &#125; &#125;&#125; .Net12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;using System.IO.Compression;using System.Text;namespace GZIPService&#123; public class ZipHelper &#123; public static string compress(string text) &#123; byte[] buffer = Encoding.UTF8.GetBytes(text); MemoryStream ms = new MemoryStream(); using (GZipStream zip = new GZipStream(ms, CompressionMode.Compress, true)) &#123; zip.Write(buffer, 0, buffer.Length); &#125; ms.Position = 0; MemoryStream outStream = new MemoryStream(); byte[] compressed = new byte[ms.Length]; ms.Read(compressed, 0, compressed.Length); byte[] gzBuffer = new byte[compressed.Length + 4]; System.Buffer.BlockCopy(compressed, 0, gzBuffer, 4, compressed.Length); System.Buffer.BlockCopy(BitConverter.GetBytes(buffer.Length), 0, gzBuffer, 0, 4); return Convert.ToBase64String(gzBuffer); &#125; public static string decompress(string compressedText) &#123; byte[] gzBuffer = Convert.FromBase64String(compressedText); using (MemoryStream ms = new MemoryStream()) &#123; int msgLength = BitConverter.ToInt32(gzBuffer, 0); ms.Write(gzBuffer, 4, gzBuffer.Length - 4); byte[] buffer = new byte[msgLength]; ms.Position = 0; using (GZipStream zip = new GZipStream(ms, CompressionMode.Decompress)) &#123; zip.Read(buffer, 0, buffer.Length); &#125; return Encoding.UTF8.GetString(buffer); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c#基础-扩展方法]]></title>
    <url>%2F2016%2F09%2F12%2Fc-%E5%9F%BA%E7%A1%80-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[扩展方法的讲解C#扩展方法，爱你在心口难开转自无风听海 什么是扩展方法?好几天了打算记录一下，今天我们来深入研究一下，探究一下扩展方法的实现机制；那么到底什么是扩展方法呢？扩展方法使您能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。扩展方法是一种特殊的静态方法，但可以像扩展类型上的实例方法一样进行调用。对于用 C# 和 Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中实际定义的方法之间没有明显的差异。也许你并不明白以上的意思，那一点都没有关系，如果我们平时一定经常使用linq标准查询，那么我们就一直在使用扩展方法啦！微软为枚举的集合扩展了很多的标准查询方法，极大的方便了我们的使用！请看下面的例子没有使用扩展方法 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Text;using wuFengTingHai.Person;namespace ExtendMethod&#123; public class LinqExtend &#123; private IList&lt;Person&gt; persons = new List&lt;Person&gt;(); public IList&lt;Person&gt; Persons &#123; get &#123; //删除集合中名称为无风听海的记录，没有引入system.linq,所以不能使用扩展方法 foreach(Person person in this.persons) &#123; if (person.Name.Equals("无风听海")) &#123; this.persons.Remove(person); &#125; &#125; return this.persons; &#125; set &#123; this.persons = value; &#125; &#125; &#125; &#125; 使用扩展方法 12345678910111213141516171819202122 using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person.Extend&#123; public class LinqExtend &#123; private IList&lt;Person&gt; persons = new List&lt;Person&gt;(); public IList&lt;Person&gt; Persons &#123; get &#123; //删除集合中名称为无风听海的记录，引入system.linq的扩展方法 this.persons = this.persons.Where(m =&gt; !m.Name.Equals("无风听海")).ToList&lt;Person&gt;(); return this.persons; &#125; set &#123; this.persons = value; &#125; &#125; &#125;&#125; 引入system.linq后,扩展方法的智能提示 从上面的例子中我们可以学到扩展方法的使用方法。那么扩展方法是怎么定义的呢？查看一下Where扩展方法的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #region Assembly System.Core.dll, v2.0.50727// C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.5\System.Core.dll#endregionusing System;using System.Collections;using System.Collections.Generic;using System.Runtime.CompilerServices;namespace System.Linq&#123; //为了方便展示，将其他的扩展方法进行了删除精简 public static class Enumerable &#123; public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate); public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate); &#125;&#125;``` 虽然扩展方法通过实例方法语法进行调用的，但是他们却被定义为静态方法。从定义中我们可以看到，它们的第一个参数指定该方法作用于哪个类型，并且该参数以 this 修饰符为前缀。 下面我们自己定义一个Person类和PersonExtend类来扩展方法，来看看编译器究竟做了什么！ ``` bash using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person&#123; public class Person &#123; public Person(string name,string sex,string age) &#123; this.name = name; this.sex = sex; this.age = age; &#125; private string name; public string Name &#123; set &#123; this.name = value; &#125; get &#123; return this.name; &#125; &#125; private string sex; public string Sex &#123; set &#123; this.sex = value; &#125; get &#123; return this.sex; &#125; &#125; private string age; public string Age &#123; set &#123; this.age = value; &#125; get &#123; return this.age; &#125; &#125; public override string ToString() &#123; return string.Format("&#123;0&#125;","类本身的方法覆盖了同名扩展方法"); &#125; &#125;&#125; PersonExtend，对Person类进行方法扩展 12345678910111213141516 using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person.Extend&#123; public static class PersonExtend &#123; public static string GetDescription(this Person person,string msg) &#123; return string.Format("&#123;0&#125; 我是&#123;1&#125;,性别&#123;2&#125;,今年&#123;3&#125;岁",msg,person.Name,person.Sex,person.Age); &#125; &#125;&#125; 客户端调用结果 让我们看一下客户端main方法的IL代码，我们就知道编译器到底干什么了！ 1234567891011121314151617181920212223242526272829303132333435 .method private hidebysig static void Main(string[] args) cil managed&#123; .entrypoint // Code size 63 (0x3f) .maxstack 4 .locals init ([0] class [wuFengTingHai.Person]wuFengTingHai.Person.Person person) IL_0000: nop IL_0001: ldstr bytearray (E0 65 CE 98 2C 54 77 6D ) // .e..,Twm IL_0006: ldstr bytearray (37 75 ) // 7u IL_000b: ldstr "20" IL_0010: newobj instance void [wuFengTingHai.Person]wuFengTingHai.Person.Person::.ctor(string, string, string) IL_0015: stloc.0 IL_0016: ldloc.0 IL_0017: ldstr bytearray (F4 76 A5 63 1A 90 C7 8F 59 97 01 60 7B 7C 50 00 // .v.c....Y..`&#123;|P. 65 00 72 00 73 00 6F 00 6E 00 45 00 78 00 74 00 // e.r.s.o.n.E.x.t. 65 00 6E 00 64 00 03 8C 28 75 2C 00 ) // e.n.d...(u,. //直接使用静态类PersonExtend调用 IL_001c: call string [wuFengTingHai.Person.Extend]wuFengTingHai.Person.Extend.PersonExtend::GetDescription(class [wuFengTingHai.Person]wuFengTingHai.Person.Person, string) IL_0021: call void [mscorlib]System.Console::WriteLine(string) IL_0026: nop IL_0027: ldloc.0 IL_0028: ldstr bytearray (F4 76 A5 63 1A 90 C7 8F 50 00 65 00 72 00 73 00 // .v.c....P.e.r.s. 6F 00 6E 00 84 76 9E 5B 8B 4F 03 8C 28 75 2C 00 ) // o.n..v.[.O..(u,. //直接使用Person的扩展方法调用 IL_002d: call string [wuFengTingHai.Person.Extend]wuFengTingHai.Person.Extend.PersonExtend::GetDescription(class [wuFengTingHai.Person]wuFengTingHai.Person.Person, string) IL_0032: call void [mscorlib]System.Console::WriteLine(string) IL_0037: nop IL_0038: call string [mscorlib]System.Console::ReadLine() IL_003d: pop IL_003e: ret&#125; // end of method Program::Main 从IL中我们可以看到扩展方法与其扩展的类之间并没有什么本质的联系，只是编译器跟我们玩的把戏罢了，最终编译器还是将扩展方法转化成静态类的静态方法调用，所以扩展方法不能访问相应类的私有字段和私有方法；至于为什么使用静态类的静态方法，我考虑可能是这样效率相对较高，同时扩展方法作为其他类的扩展，本身类的实例化没有什么意义； 如果扩展方法和被扩展类中的方法相同，会怎么样？ 123456789101112131415161718192021 using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person.Extend&#123; public static class PersonExtend &#123; public static string GetDescription(this Person person,string msg) &#123; return string.Format("&#123;0&#125; 我是&#123;1&#125;,性别&#123;2&#125;,今年&#123;3&#125;岁",msg,person.Name,person.Sex,person.Age); &#125; public static string ToString(this Person person) &#123; return "扩展方法能够覆盖原始类的同名方法"; &#125; &#125;&#125; 客户端调用代码 123456789101112131415161718192021 using System;using System.Collections.Generic;using System.Linq;using System.Text;using wuFengTingHai.Person.Extend;namespace ExtendMethod&#123; class Program &#123; static void Main(string[] args) &#123; wuFengTingHai.Person.Person person = new wuFengTingHai.Person.Person("无风听海", "男", "20"); //Console.WriteLine(wuFengTingHai.Person.Extend.PersonExtend.GetDescription(person, "直接通过静态类PersonExtend调用,")); //Console.WriteLine(person.GetDescription("直接通过Person的实例调用,")); Console.WriteLine(person.ToString()); Console.ReadLine(); &#125; &#125;&#125; 调用结果 以上我们可以看到编译时，扩展方法的优先级总是比类型本身中定义的实例方法低，所以与接口或类方法具有相同名称和签名的扩展方法永远不会被调用。 综上进行总结 扩展方法不改变被扩展类的代码，不用重新编译、修改、派生被扩展类 扩展方法不能访问被扩展类的私有成员 扩展方法会被被扩展类的同名方法覆盖，所以实现扩展方法我们需要承担随时被覆盖的风险 扩展方法看似实现了面向对象中扩展对修改说不的特性，但是也违背了面向对象的继承原则，被扩展类的派生类是不能继承扩展扩展方法的，从而又违背了面向对象的多态性。 在我们稳定的引用同一个版本的类库，但是我们没有该类库的源代码，那么我们可以使用扩展方法；但是从项目的可扩展、可维护和版本控制方面来说，都不建议 使用扩展方法进行类的扩展。]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>扩展方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图常用功能的使用]]></title>
    <url>%2F2016%2F09%2F10%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[百度地图API使用 资料1.JavaScript API2.demo3.工具开源库（如鼠标点击后计算范围、聚合效果等） 常用的功能及实现引入资源包引入常用的资源包（引入http://api.map.baidu.com/api?v=2.0&amp;ak=tzAcIFZ5xCoRwm63NcBGfoVB 时ak是自己申请的一个秘钥）1234567891011121314&lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;!--jquery--&gt; &lt;!--百度地图--&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=tzAcIFZ5xCoRwm63NcBGfoVB"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.css" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/SearchInfoWindow/1.5/src/SearchInfoWindow_min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="http://api.map.baidu.com/library/SearchInfoWindow/1.5/src/SearchInfoWindow_min.css" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/AreaRestriction/1.2/src/AreaRestriction_min.js"&gt;&lt;/script&gt; &lt;!--聚合--&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/TextIconOverlay/1.2/src/TextIconOverlay_min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer.js"&gt;&lt;/script&gt; &lt;!--聚合--&gt; &lt;!--百度地图--&gt; 初始化地图1$(function()&#123; /*所有js代码放入*/&#125;); 设置中心点创建地图对象设置中心点以及缩放的级别zoom123456789// 百度地图API功能 var map = new BMap.Map("allmap"); // 创建Map实例 /*centerAndZoom(center:Point, zoom:Number) none 设初始化地图。 &lt;span style="color:#ff0000;"&gt; 如果center类型为Point时，zoom必须赋值，范围3-19级，&lt;/span&gt;若调用高清底图（针对移动端开发）时， zoom可赋值范围为3-18级。如果&lt;span style="color:#ff0000;"&gt;center类型为字符串时，比如“北京”，zoom可以忽略&lt;/span&gt;，地图将自动根据center适配最佳zoom级别。 */ //map.centerAndZoom(new BMap.Point(113.195425, 39.657158), 10); //初始化地图,设置中心点坐标和地图级别 map.centerAndZoom("北京市"); &#125;); 插入缩放定位等控件12345678910 var navigationControl = new BMap.NavigationControl(&#123;// 靠左上角位置anchor: BMAP_ANCHOR_TOP_LEFT,// LARGE类型type: BMAP_NAVIGATION_CONTROL_LARGE,// 启用显示定位enableGeolocation: true,showZoomInfo: true, &#125;); map.addControl(navigationControl); 开启滚轮缩放及禁用双击放大12map.enableScrollWheelZoom(); //开启鼠标滚轮缩放map.disableDoubleClickZoom(true);//禁用双击放大。 限制地图显示区域超出显示区域自动修改回限制区域，参数需要两个点的坐标，即限制区域地图的左上角和右下角坐标1234567//限制区域 var b = new BMap.Bounds(new BMap.Point(111.822527, 40.296748), new BMap.Point(114.566024,39.043834)); try &#123; BMapLib.AreaRestriction.setBounds(map, b); &#125; catch (e) &#123; alert(e); &#125; 添加行政区域（县、区级别）123456789101112131415161718function getBoundary() &#123; var bdary = new BMap.Boundary(); bdary.get("西安市雁塔区", function (rs) &#123; //获取行政区域 map.clearOverlays(); //清除地图覆盖物 var count = rs.boundaries.length; //行政区域的点有多少个 if (count === 0) &#123; alert('未能获取当前输入行政区域'); return; &#125; var pointArray = []; for (var i = 0; i &lt; count; i++) &#123; var ply = new BMap.Polygon(rs.boundaries[i], &#123; strokeWeight: 2, strokeColor: "#ff0000" &#125;); //建立多边形覆盖物 map.addOverlay(ply); //添加覆盖物 pointArray = pointArray.concat(ply.getPath()); &#125; map.setViewport(pointArray); //调整视野 &#125;); &#125; 结合后台获得制定区域并画出1234567891011121314151617181920ShowArea(); //读取已有区域 function ShowArea() &#123; $.post("Handler.ashx?action=getAreaData", "", function (data, status) &#123; //var data = eval(dataJSON); var points = GetPointsArray(data); var polygon1 = new BMap.Polygon(points, &#123; strokeColor: "blue", fillColor: "#f0979f", strokeWeight: 2, strokeOpacity: 0.5, fillOpacity: 0.3 &#125;); //创建多边形 map.addOverlay(polygon1); //增加多边形 &#125;); &#125; function GetPointsArray(points) &#123; var pointsArray = points.split(";"); var result = new Array(); for (var i = 0; i &lt; pointsArray.length; i++) &#123; result[i] = new BMap.Point(pointsArray[i].split(",")[0], pointsArray[i].split(",")[1]); &#125; return result; &#125; 后台获得区域（点的集合）使用ajax与一般处理程序1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace WebApplication3&#123; /// &lt;summary&gt; /// Handler 的摘要说明 /// &lt;/summary&gt; public class Handler : IHttpHandler &#123; public void ProcessRequest(HttpContext context) &#123; string action=context.Request["action"]; switch(action) &#123; case "getAreaData": GetAreaData(context); break; &#125; &#125; public void GetAreaData(HttpContext context) &#123; string s = "108.860872, 34.258506;108.831975, 34.258587;108.827325, 34.254061;108.82198, 34.253861;108.821721, 34.242147;108.82502, 34.242241;108.825366, 34.235732;108.828081, 34.235904;108.828549, 34.225515;108.841104, 34.22704;108.836877, 34.210519;108.839338, 34.205291;108.852262, 34.206639;108.852829, 34.18584;108.875588, 34.185636;108.875624, 34.177398;108.980798, 34.177959;109.00823, 34.180186;109.022781, 34.185512;109.039102, 34.182088;109.060345, 34.191182;109.053019, 34.212803;109.056843, 34.243072;109.054189, 34.257263;109.033871, 34.257004;109.036981, 34.256214;109.037215, 34.240337;109.027373, 34.240809;109.027372, 34.243714;109.022632, 34.243735;109.02261, 34.248791;109.002924, 34.248887;108.971729, 34.236415;108.938526, 34.235527;108.897292, 34.253332;108.89572, 34.257881;108.860872, 34.258506"; context.Response.Write(s); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125;&#125; 点聚合及批量弹出窗口12345678910111213141516171819202122232425262728293031323334353637383940414243// 百度地图API功能 var map = new BMap.Map("allmap"); map.centerAndZoom(new BMap.Point(116.404, 39.915), 4); map.enableScrollWheelZoom(); var MAX = 10; var markers = []; var pt = null; var i = 0; for (; i &lt; MAX; i++) &#123; pt = new BMap.Point(Math.random() * 40 + 85, Math.random() * 30 + 21); var marker = new BMap.Marker(pt); markers.push(marker); var content1 = '&lt;div style="margin:0;line-height:20px;padding:2px;"&gt;内容&lt;/div&gt;'; markers.push(marker); &lt;span style="color:#ff0000;"&gt; //使用闭包 这样内容才能显示的不同，否则全部都会只显示最后一个content1的内容&lt;/span&gt; (function (content1) &#123; marker.addEventListener("click", function (e) &#123; //创建检索信息窗口对象 var searchInfoWindow = null; searchInfoWindow = new BMapLib.SearchInfoWindow(map, content1, &#123; title: '信息&lt;a target="_top" onclick="alert(1)" style="margin-left:5px;font-size:12px;line-height:30px;color:#3d6dcc;font-weight:normal;text-decoration:none;cursor:pointer;"&gt;详情»&lt;/a&gt;', //标题 width: 250, //宽度 height: 200, //高度 panel: "panel", //检索结果面板 enableAutoPan: true, //自动平移 enableSendToPhone: false,//百度发送短信图标 searchTypes: [ //BMAPLIB_TAB_SEARCH, //周边检索 //BMAPLIB_TAB_TO_HERE, //到这里去 //BMAPLIB_TAB_FROM_HERE //从这里出发 ] &#125;); searchInfoWindow.open(e.target); &#125;); &#125;)(content1) &#125; //最简单的用法，生成一个marker数组，然后调用markerClusterer类即可。 var markerClusterer = new BMapLib.MarkerClusterer(map, &#123; markers: markers &#125;);]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>百度地图</tag>
        <tag>地图操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4Net生成空日志文件的解决方法]]></title>
    <url>%2F2016%2F09%2F10%2FLog4Net%E7%94%9F%E6%88%90%E7%A9%BA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[设置Log4Net并自动删除空日志1、根据网上的配置说明，该配置将记录Error 级别的错误，按照月份分文件夹，按照天来分文件进行日志的记录，完成了配置如下：123456789101112131415161718192021222324252627282930313233&lt;configuration&gt; &lt;configSections&gt; &lt;section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net, Version=1.2.11.0, Culture=neutral, PublicKeyToken=1B44E1D426115821" /&gt; &lt;/configSections&gt; &lt;log4net&gt; &lt;root&gt; &lt;!--&lt;level value="DEBUG"/&gt;--&gt; &lt;level value="ERROR"/&gt; &lt;!--根据log级别记录到不同的日志文件--&gt; &lt;!--&lt;appender-ref ref="DebugLog" /&gt;--&gt; &lt;appender-ref ref="ErrorLog" /&gt; &lt;/root&gt; &lt;appender name="ErrorLog" type="log4net.Appender.RollingFileAppender"&gt; &lt;!-- 最后放开注释--&gt; &lt;!--&lt;lockingModel type="命名空间.MinimalLockDeleteEmpty" /&gt;--&gt; &lt;param name="File" value="Log\" /&gt; &lt;param name="AppendToFile" value="true" /&gt; &lt;param name="RollingStyle" value="Date" /&gt; &lt;param name="DatePattern" value="yyyy-MM\\yyyy-MM-dd.'log'" /&gt; &lt;param name="StaticLogFileName" value="false" /&gt; &lt;layout type="log4net.Layout.PatternLayout"&gt; &lt;conversionPattern value="%date [%thread] %-5level %logger - %message%newline" /&gt; &lt;/layout&gt; &lt;securityContext type="log4net.Util.WindowsSecurityContext"&gt; &lt;credentials value="Process" /&gt; &lt;/securityContext&gt; &lt;filter type="log4net.Filter.LevelRangeFilter"&gt; &lt;levelMin value="ERROR" /&gt; &lt;levelMax value="ERROR" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;/log4net&gt;&lt;/configuration&gt; 2、运行上面的（除红色）的设置后，发现就算没有抛出异常，log4net每天同样会创建一个空的日志文件。3、查找搜索了下国内网站，未发现解决的方法，只是想到如果log4net不支持的化，可以在网站运行后创建一个定时器，每隔一天检查一下对应的日志文件是否有空，有则删除；4、google搜索到国外的网站，发现可以继承FileAppender.MinimalLock类 重写ReleaseLock 方法 来实现写日志完成后检查空文件并删除的功能。引用地址1234567891011121314151617181920212223using log4net.Appender;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;namespace 命名空间&#123; public class MinimalLockDeleteEmpty : FileAppender.MinimalLock &#123; public override void ReleaseLock() &#123; base.ReleaseLock(); var logFile = new FileInfo(CurrentAppender.File); if (logFile.Exists &amp;&amp; logFile.Length &lt;= 0) &#123; logFile.Delete(); &#125; &#125; &#125;&#125; 5、最后在配置文件中将类插入完成调用1&lt;lockingModel type="命名空间.MinimalLockDeleteEmpty" /&gt; 6、最后Log4Net效果就是记录中没有空日志文件且存放服务器时按照月份建文件夹，文件夹内按照日期建日志文件。]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Log4Net</tag>
        <tag>ASP.NET日志</tag>
        <tag>空日志删除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>