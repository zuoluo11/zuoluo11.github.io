<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[枚举使用备忘]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[简介Enum为枚举提供基类，其基础类型可以是除 Char 外的任何整型。如果没有显式声明基础类型，则使用Int32。编程语言通常提供语法来声明由一组已命名的常数和它们的值组成的枚举。注意：枚举类型的基类型是除 Char 外的任何整型，所以枚举类型的值是整型值。 Enum 提供一些实用的静态方法： (1)比较枚举类的实例的方法 (2)将实例的值转换为其字符串表示形式的方法 (3)将数字的字符串表示形式转换为此类的实例的方法 (4)创建指定枚举和值的实例的方法。 示例代码常用的就是将枚举按照字符串输出展示与枚举值（整形）保存到数据库。1234567891011121314151617181920212223242526using System;namespace EnumDemo&#123; class Program &#123; static void Main(string[] args) &#123; string[] temp = System.Enum.GetNames(new MyColor().GetType());//获得枚举数组 //Enum-&gt;string Console.WriteLine(MyColor.兰.ToString());//输出：兰 Console.WriteLine(Enum.GetName(typeof(MyColor), 2));//按照下标获得指定枚举，输出：兰 Console.WriteLine(temp[2]);//输出：兰 //Enum-&gt;int int intValue = Convert.ToInt32(MyColor.兰); Console.WriteLine(intValue);//输出：2 Console.Read(); &#125; &#125; public enum MyColor &#123; 红, 黄, 兰, 黑, 白, 橙, 紫 &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ASP MVC 微信公众号通用授权]]></title>
    <url>%2F2018%2F05%2F30%2Faspmvc%E9%80%9A%E7%94%A8%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[使用ASP MVC的注解方式，简易的将微信公众号内的实现网页自动登录。 问题描述：在微信公众号增加网页菜单，实现用户微信号与系统自动绑定并登录的功能。 实现原理所谓网站的自动登录，其实就是将用户微信的openid与系统的账号进行绑定，然后进行登录的过程。 微信接口介绍在公众号下每一个用户都有独一无二的openid，因此可以使用这个唯一标识来进行登录权限的认证。要获得用户的openid，需要使用微信提供的接口，即官网名称：微信网页授权 该授权的类型有两种：第一种：静默跳转模式（scope的值是snsapi_base）优点：可以在用户没有感觉的情况下获得openid缺点：用户需要关注微信公众号且后续如果需要获得用户的信息需要调用获取用户基本信息接口 第二种：非静默的跳转模式（scope的值是snsapi_userinfo）优点：两步合为一步，直接获得用户的信息，用户可以不关注公众号缺点：用户会弹出页面提示是否需要授权（已关注用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，则是静默授权） 实现代码原理使用ASP MVC 中的注解模式，将需要授权的登录页Action增加注解实现自动登录。 1.创建授权注解类：将注解类新见到文件夹App_Start下并继承自父类AuthorizeAttribute；2.登录Action上增加注解并在内部判断session中的openid是否存在来自动跳转登录页； 实现过程微信公众号后台需要设置 完成上面的步骤后，准备工作做完，开始进行编码。 代码实现静默方式授权注解类代码参考地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133using Newtonsoft.Json;using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;namespace Learun.Application.Web&#123; /// &lt;summary&gt; /// 微信授权 /// &lt;/summary&gt; public class WXFilterAttribute : AuthorizeAttribute &#123; protected override bool AuthorizeCore(HttpContextBase httpContext) &#123; httpContext.Session.Remove("weixinInfo"); string userAgent = httpContext.Request.UserAgent; if (userAgent.IndexOf("MicroMessenger") &lt;= -1)//不是微信浏览器 &#123; httpContext.Response.StatusCode = 400001; return false; &#125; if (!httpContext.User.Identity.IsAuthenticated) &#123; //ApplicationSignInManager SignInManager = httpContext.GetOwinContext().Get&lt;ApplicationSignInManager&gt;(); //ApplicationUserManager UserManager = httpContext.GetOwinContext().GetUserManager&lt;ApplicationUserManager&gt;(); string appid = string.Empty; string secret = string.Empty; appid ="**********"; secret = "##################"; var code = httpContext.Request["Code"]; string returnUrl = HttpUtility.UrlDecode(httpContext.Request["ReturnUrl"] ?? "/"); if (string.IsNullOrEmpty(code)) &#123; string host = httpContext.Request.Url.Host; string path = httpContext.Request.Path; string redirectUrl = "http://" + host + path + "?ReturnUrl=" + HttpUtility.UrlEncode(returnUrl);//重定向的url，这里不需要进行编码，在后面会自己编码 try &#123; //todo:通过微信获取2.0授权的url string url = GetAuthorizeUrl(appid, redirectUrl, "state", "snsapi_base"); httpContext.Response.Redirect(url); &#125; catch (System.Exception ex) &#123;#if DEBUG httpContext.Response.Write("构造网页授权获取code的URL时出错，错误是：" + ex.Message); httpContext.Response.End();#endif &#125; &#125; else &#123; var client = new System.Net.WebClient(); client.Encoding = System.Text.Encoding.UTF8; string url = GetAccessTokenUrl(appid, secret, code); var data = client.DownloadString(url); var obj = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, string&gt;&gt;(data); if (obj.ContainsKey("errcode") &amp;&amp; obj["errcode"] == "40163") &#123; //刷新页面,重新进入 httpContext.Response.Redirect("/SFJD_WeixinModule/WeiXinLogin/Login"); return true; &#125; string accessToken; if (!obj.TryGetValue("access_token", out accessToken)) &#123;#if DEBUG httpContext.Response.Write("构造网页授权获取access_token的URL时出错"); httpContext.Response.End();#endif &#125; var openid = obj["openid"]; httpContext.Session["weixinInfo"] = openid; //Utils.WidgetCode.ServerInfo.SetCookies("WXopenid", openid, DateTime.MinValue); //var existUser = UserManager.Users.FirstOrDefault(p =&gt; p.OpenId == openid); //if (existUser != null) //&#123; // SignInManager.SignInAsync(existUser, false, false); // httpContext.Response.Redirect(returnUrl); //&#125; &#125; &#125; return true; &#125; public override void OnAuthorization(AuthorizationContext filterContext) &#123; base.OnAuthorization(filterContext); if (filterContext.HttpContext.Response.StatusCode == 401) &#123; filterContext.Result = new RedirectResult("/SFJD_WeixinModule/WeiXinLogin/Error?errorMsg=微信授权登录异常"); &#125; else if (filterContext.HttpContext.Response.StatusCode == 400001) &#123; filterContext.Result = new RedirectResult("/SFJD_WeixinModule/WeiXinLogin/Error?errorMsg=请在微信中打开该页面"); &#125; &#125; //扩展 public string GetAuthorizeUrl(string appId, string redirectUrl, string state, string scope, string responseType = "code") &#123; if (!string.IsNullOrEmpty(redirectUrl)) &#123; redirectUrl = HttpUtility.UrlEncode(redirectUrl, System.Text.Encoding.UTF8); &#125; else &#123; redirectUrl = null; &#125; object[] args = new object[] &#123; appId, redirectUrl, responseType, scope, state &#125;; return string.Format("https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#123;0&#125;&amp;redirect_uri=&#123;1&#125;&amp;response_type=&#123;2&#125;&amp;scope=&#123;3&#125;&amp;state=&#123;4&#125;#wechat_redirect", args); &#125; public string GetAccessTokenUrl(string appId, string secret, string code, string grantType = "authorization_code") &#123; object[] args = new object[] &#123; appId, secret, code, grantType &#125;; string requestUri = string.Format("https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#123;0&#125;&amp;secret=&#123;1&#125;&amp;code=&#123;2&#125;&amp;grant_type=&#123;3&#125;", args); //return GetAccessTokenInfo(_httpClient.GetAsync(requestUri).Result.Content.ReadAsStringAsync().Result); return requestUri; &#125; &#125;&#125; 登录控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class WeiXinLoginController : MvcWXControllerBase &#123; // GET: SFJD_WeixinModule/WeiXinLogin #region 视图 /// &lt;summary&gt; /// 登录 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [WXFilter] public ActionResult Index() &#123; string openID = GetOpenID(); if (!string.IsNullOrEmpty(openID)) &#123; using (MAction action = new MAction(TableNames.SFJD_Client)) &#123; if (action.Fill(string.Format("OpenID='&#123;0&#125;'", openID))) &#123; //TODO:设置用户信息 //跳转首页 return RedirectToAction("Index", "WeiXinMain"); &#125; &#125; &#125; //第一次登录去注册界面 return View(); &#125; /// &lt;summary&gt; /// 获得当前OpenID /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetOpenID() &#123; if (Session["weixinInfo"] == null) &#123; return ""; &#125; else &#123; return Convert.ToString(Session["weixinInfo"]); &#125; &#125; &#125; 后续之前遇到了一个问题，在本地测试公众号下没有发现系统有什么异常，发布到远程服务器及正式公众号下时，跳出异常信息“输入字符串的格式不正确。”，找了半天认为应该是哪里转字符串的地方出问题了，可是一开始没找到。最后使用日志输出的方式将问题定位到了获得用户基本信息后，放置token过期时间上。1异常信息&#123;&quot;errcode&quot;:40164,&quot;errmsg&quot;:&quot;invalid ip 111.111.112.117, not in whitelist hint: [yYexhA05332994]&quot;&#125; 发现公众号未设置白名单导致。 在IP白名单内的IP来源，获取access_token接口才可调用成功。 设置完成后，问题解决。 获得微信用户信息的工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using CYQ.Data.Cache;using CYQ.Data.Tool;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Util.WeiXin&#123; /// &lt;summary&gt; /// 微信公众号工具类 /// &lt;/summary&gt; public class WeiXinTool &#123; /// &lt;summary&gt; /// 获得已关注公众号用户信息 /// &lt;/summary&gt; /// &lt;param name="openid"&gt;&lt;/param&gt; /// &lt;param name="appID"&gt;&lt;/param&gt; /// &lt;param name="appSecret"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetVisiterInfo(string openid) &#123; string appID = "#########"; string appSecret = "******************"; string access_token = GetAccess_token(appID, appSecret); string requestURL = "https://api.weixin.qq.com/cgi-bin/user/info?access_token=&#123;0&#125;&amp;openid=&#123;1&#125;&amp;lang=zh_CN "; string strJson = HttpRequestUtil.RequestUrl(string.Format(requestURL, access_token, openid)); return strJson; &#125; /// &lt;summary&gt; /// 获得基础接口的access_token /// &lt;/summary&gt; /// &lt;param name="appID"&gt;&lt;/param&gt; /// &lt;param name="appSecret"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetAccess_token(string appID, string appSecret) &#123; string access_token = ""; CacheManage cache = CacheManage.Instance; if (cache.Contains("access_token" + appID)) &#123; access_token = cache.Get("access_token" + appID) as string; &#125; else &#123; string strJson = ""; string requestURL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;0&#125;&amp;secret=&#123;1&#125;"; strJson = HttpRequestUtil.RequestUrl(string.Format(requestURL, appID, appSecret)); access_token = JsonHelper.GetValue(strJson, "access_token"); double cacheMinutes = (double)(Convert.ToInt32(JsonHelper.GetValue(strJson, "expires_in")) / 60);//将秒转换为分钟 cache.Set("access_token" + appID, access_token, cacheMinutes); &#125; return access_token; &#125; &#125;&#125;]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进度检查]]></title>
    <url>%2F2018%2F05%2F11%2F%E8%BF%9B%E5%BA%A6%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018阅读书单]]></title>
    <url>%2F2018%2F01%2F22%2F2018%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[一月：《大话设计模式》]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-装饰模式]]></title>
    <url>%2F2018%2F01%2F16%2FDecoratorPattern%2F</url>
    <content type="text"><![CDATA[1、 装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。 2、组合和继承的区别 继承。继承是给一个类添加行为的比较有效的途径。通过使用继承，可以使得子类在拥有自身方法的同时，还可以拥有父类的方法。但是使用继承是静态的，在编译的时候就已经决定了子类的行为，我们不便于控制增加行为的方式和时机。 组合。组合即将一个对象嵌入到另一个对象中，由另一个对象来决定是否引用该对象来扩展自己的行为。这是一种动态的方式，我们可以在应用程序中动态的控制。 与继承相比，组合关系的优势就在于不会破坏类的封装性，且具有较好的松耦合性，可以使系统更加容易维护。但是它的缺点就在于要创建比继承更多的对象。 3、装饰者模式的优缺点 优点 a.装饰者模式可以提供比继承更多的灵活性b.可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。c.通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。d.具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。 缺点 a.会产生很多的小对象，增加了系统的复杂性b.这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 4、装饰者的使用场景 a.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。b.需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。c.当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。 以上内容来自网络 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System;namespace SettingPattern4&#123; /// &lt;summary&gt; /// Decorator Pattern 装饰模式 /// 优点：通过动态的方式为类附加功能 /// &lt;/summary&gt; class Customer &#123; static void Main(string[] args) &#123; Person p = new Student(); ConcreteStudent1 c1 = new ConcreteStudent1(); ConcreteStudent2 c2 = new ConcreteStudent2(); c1.SetPerson(p); c2.SetPerson(c1); c2.Operate(); Console.Read(); &#125; &#125; public abstract class Person &#123; public abstract void Operate(); &#125; public class Student : Person &#123; public override void Operate() &#123; Console.WriteLine("原始Student操作"); &#125; &#125; public abstract class Decorator : Person &#123; private Person person; public void SetPerson(Person person) &#123; this.person = person; &#125; public override void Operate() &#123; if (person != null) &#123; person.Operate(); &#125; &#125; &#125; public class ConcreteStudent1 : Decorator &#123; public override void Operate() &#123; base.Operate(); Console.WriteLine("ConcreteStudent1添加操作"); &#125; public void Print() &#123; Console.WriteLine("ConcreteStudent1 Print"); &#125; &#125; public class ConcreteStudent2 : Decorator &#123; public override void Operate() &#123; base.Operate(); Console.WriteLine("ConcreteStudent2添加操作"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式-抽象工厂模式]]></title>
    <url>%2F2018%2F01%2F11%2FAbstractFactoryPattern%2F</url>
    <content type="text"><![CDATA[抽象工厂模式一句话：一个工厂抽象类，多个产品抽象类，一个工厂生产一个产品族（多个有关系的产品组合）。 简单工厂模式：一个工厂生产多个产品工厂方法模式：一个工厂生产一个产品抽象工厂模式：一个工厂生产一个产品族 首先下面有一个关于电脑的工厂方法模式，稍后将它改造为抽象工厂模式。 业务逻辑分析：a.电脑配件有鼠标、键盘、屏幕。b.顾客拿到配件后进行组装使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;namespace SettingPattern4&#123; class Customer &#123; static void Main(string[] args) &#123; Parts mouse = new MouseFactory().CreateFruit(); mouse.PrintName(); Console.WriteLine("-------------"); Parts keyboard = new KeyboardFactory().CreateFruit(); keyboard.PrintName(); Console.WriteLine("-------------"); Parts screen = new ScreenFactory().CreateFruit(); screen.PrintName(); Console.Read(); &#125; &#125; /// &lt;summary&gt; /// 工厂抽象类 /// &lt;/summary&gt; public abstract class Factory &#123; public abstract Parts CreateFruit(); &#125; /// &lt;summary&gt; /// 鼠标工厂类 /// &lt;/summary&gt; public class MouseFactory : Factory &#123; public override Parts CreateFruit() &#123; return new Mouse(); &#125; &#125; /// &lt;summary&gt; /// 键盘工厂类 /// &lt;/summary&gt; public class KeyboardFactory : Factory &#123; public override Parts CreateFruit() &#123; return new KeyBoard(); &#125; &#125; /// &lt;summary&gt; /// 屏幕工厂类 /// &lt;/summary&gt; public class ScreenFactory : Factory &#123; public override Parts CreateFruit() &#123; return new Screen(); &#125; &#125; /// &lt;summary&gt; /// 配件抽象类 /// &lt;/summary&gt; public abstract class Parts &#123; /// &lt;summary&gt; /// 配件抽象方法 /// &lt;/summary&gt; public abstract void PrintName(); &#125; /// &lt;summary&gt; /// 鼠标类 /// &lt;/summary&gt; public class Mouse : Parts &#123; public override void PrintName() &#123; Console.WriteLine("This is an mouse."); &#125; &#125; /// &lt;summary&gt; /// 键盘类 /// &lt;/summary&gt; public class KeyBoard : Parts &#123; public override void PrintName() &#123; Console.WriteLine("This is a keyboard"); &#125; &#125; /// &lt;summary&gt; /// 屏幕类 /// &lt;/summary&gt; public class Screen : Parts &#123; public override void PrintName() &#123; Console.WriteLine("This is a screen"); &#125; &#125;&#125; 问题提出：顾客认为自己配置电脑太累，打算直接购买品牌机。很明显：上面的代码中没有体现出各个配件之间的关系且最后由用户进行组装，现在配件内部存在关联关系且由工厂组装好后直接给用户使用。此处可以看出横向扩展配件，如加入一个耳机比较容易，如果要加入一个纵向的产品族则很复杂。 业务描述：a.品牌机的配件都只有该品牌自己的标识，因此各个配件内部都有关系，不会买惠普的电脑里出现联想的鼠标；b.顾客现在可以买惠普的也可以买联想的； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152using System;namespace SettingPattern4&#123; class Customer &#123; static void Main(string[] args) &#123; Factory factory = new LenovoFactory(); factory.CreateKeyboard().PrintName(); factory.CreateMouse().PrintName(); factory.CreateScreen().PrintName(); Console.WriteLine("-----切换厂家-----"); factory = new HPFactory(); factory.CreateKeyboard().PrintName(); factory.CreateMouse().PrintName(); factory.CreateScreen().PrintName(); Console.Read(); &#125; &#125; /// &lt;summary&gt; /// 工厂抽象类 /// &lt;/summary&gt; public abstract class Factory &#123; public abstract MouseBase CreateMouse(); public abstract KeyboardBase CreateKeyboard(); public abstract ScreenBase CreateScreen(); &#125; public abstract class MouseBase &#123; public abstract void PrintName(); &#125; public abstract class KeyboardBase &#123; public abstract void PrintName(); &#125; public abstract class ScreenBase &#123; public abstract void PrintName(); &#125; /// &lt;summary&gt; /// HP工厂类 /// &lt;/summary&gt; public class HPFactory : Factory &#123; public override KeyboardBase CreateKeyboard() &#123; return new HPKeyBoard(); &#125; public override MouseBase CreateMouse() &#123; return new HPMouse(); &#125; public override ScreenBase CreateScreen() &#123; return new HPScreen(); &#125; &#125; /// &lt;summary&gt; /// Lenovo工厂类 /// &lt;/summary&gt; public class LenovoFactory : Factory &#123; public override KeyboardBase CreateKeyboard() &#123; return new LenovoKeyBoard(); &#125; public override MouseBase CreateMouse() &#123; return new LenovoMouse(); &#125; public override ScreenBase CreateScreen() &#123; return new LenovoScreen(); &#125; &#125; /// &lt;summary&gt; /// HP鼠标类 /// &lt;/summary&gt; public class HPMouse : MouseBase &#123; public override void PrintName() &#123; Console.WriteLine("This is HP鼠标."); &#125; &#125; /// &lt;summary&gt; /// lenovo鼠标类 /// &lt;/summary&gt; public class LenovoMouse : MouseBase &#123; public override void PrintName() &#123; Console.WriteLine("This is lenovo鼠标."); &#125; &#125; /// &lt;summary&gt; /// HP键盘类 /// &lt;/summary&gt; public class HPKeyBoard : KeyboardBase &#123; public override void PrintName() &#123; Console.WriteLine("This is HP键盘"); &#125; &#125; /// &lt;summary&gt; /// Lenovo键盘类 /// &lt;/summary&gt; public class LenovoKeyBoard : KeyboardBase &#123; public override void PrintName() &#123; Console.WriteLine("This is a Lenovo键盘"); &#125; &#125; /// &lt;summary&gt; /// HP屏幕类 /// &lt;/summary&gt; public class HPScreen : ScreenBase &#123; public override void PrintName() &#123; Console.WriteLine("This is HP屏幕"); &#125; &#125; /// &lt;summary&gt; /// Lenovo屏幕类 /// &lt;/summary&gt; public class LenovoScreen : ScreenBase &#123; public override void PrintName() &#123; Console.WriteLine("This is Lenovo屏幕"); &#125; &#125;&#125; 此时，如果想添加一个华硕的计算机，需要做如下修改：a.创建华硕的配件每个配件都继承该配件的抽象类；b.创建华硕的工厂类继承工厂抽象类；c.顾客直接创建华硕工厂获得计算机； 这里的总结的很好： 工厂创建一种产品，抽象工厂创建的是一组产品，是一个产品系列。这里要注意的是“系列”的意思，也就是说，抽象工厂创建出的一组产品是成套的。当你发现，有一个接口可以有多种实现的时候，可以考虑使用工厂方法来创建实例。当你返现，有一组接口可以有多种实现方案的时候，可以考虑使用抽象工厂创建实例组。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法模式]]></title>
    <url>%2F2018%2F01%2F10%2FFactoryMethodPattern%2F</url>
    <content type="text"><![CDATA[工厂方法模式一句话：一个产品抽象类，一个工厂抽象类，一个工厂生产一个产品。 简单工厂模式如果扩展多个产品，需要修改工厂类中的静态方法，明显不符合开放关闭原则（新增开放修改关闭）,引入工厂方法模式。本篇内容只针对工厂方法模式（Factory Method Pattern）。 简单工厂模式基础代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;namespace SettingPattern4&#123; class Customer &#123; static void Main(string[] args) &#123; //实例化苹果和香蕉 Fruit first = FruitFactory.CreateFruit("Apple"); first.PrintName(); Console.WriteLine("-------------"); Fruit second = FruitFactory.CreateFruit("Banana"); second.PrintName(); Console.Read(); &#125; &#125; /// &lt;summary&gt; /// 水果工厂类 /// &lt;/summary&gt; public class FruitFactory &#123; /// &lt;summary&gt; /// 静态水果生产方法 /// &lt;/summary&gt; /// &lt;param name="fruitName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Fruit CreateFruit(string fruitName) &#123; Fruit result; switch (fruitName) &#123; case "Apple": result = new Apple(); break; case "Banana": result = new Banana(); break; default: result = new Apple();//未找到返回一个苹果 break; &#125; return result; &#125; &#125; /// &lt;summary&gt; /// 水果抽象类 /// &lt;/summary&gt; public abstract class Fruit &#123; /// &lt;summary&gt; /// 水果抽象方法 /// &lt;/summary&gt; public abstract void PrintName(); &#125; /// &lt;summary&gt; /// 苹果类 /// &lt;/summary&gt; public class Apple : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is an apple."); &#125; &#125; /// &lt;summary&gt; /// 香蕉类 /// &lt;/summary&gt; public class Banana : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is a banana"); &#125; &#125;&#125; 在上面的代码基础上进行增加一个橘子类，需要做哪些修改呢？a.创建橘子类继承水果并实现抽象方法PrintName；b.修改水果工厂CreateFruit方法，增加case分支语句；c.修改客户类，增加获得橘子的语句；代码如下： 12345678910/// &lt;summary&gt; /// 橘子类 /// &lt;/summary&gt; public class Orange : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is a orange"); &#125; &#125; 12345678910111213141516171819/// &lt;summary&gt; /// 静态水果生产方法 /// &lt;/summary&gt; /// &lt;param name="fruitName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Fruit CreateFruit(string fruitName) &#123; Fruit result; switch (fruitName) &#123; case "Apple": result = new Apple(); break; case "Banana": result = new Banana(); break; case "Orange": result = new Orange(); break;//增加橘子分支 default: result = new Apple();//未找到返回一个苹果 break; &#125; return result; &#125; 123456789101112131415static void Main(string[] args) &#123; //实例化苹果和香蕉 Fruit first = FruitFactory.CreateFruit("Apple"); first.PrintName(); Console.WriteLine("-------------"); Fruit second = FruitFactory.CreateFruit("Banana"); second.PrintName(); Console.WriteLine("-------------"); //增加实例化橘子 Fruit third = FruitFactory.CreateFruit("Orange"); third.PrintName(); Console.Read(); &#125; 做完上面的工作后，可以发现增加一个产品需要修改工厂类方法，明显违背开放关闭原则。因此将上面的代码进一步进行整理（修改成为工厂方法模式）。a.新增抽象工厂类;b.针对每个产品都增加一个对应的工厂类；c.顾客使用时，使用对应的工厂类来创建产品； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101using System;namespace SettingPattern4&#123; class Customer &#123; static void Main(string[] args) &#123; //实例化苹果和香蕉 Fruit first = new AppleFactory().CreateFruit(); first.PrintName(); Console.WriteLine("-------------"); Fruit second = new BananaFactory().CreateFruit(); second.PrintName(); Console.WriteLine("-------------"); //实例化橘子 Fruit third = new OrangeFactory().CreateFruit(); third.PrintName(); Console.Read(); &#125; &#125; /// &lt;summary&gt; /// 水果工厂类抽象类 /// &lt;/summary&gt; public abstract class FruitFactory &#123; public abstract Fruit CreateFruit(); &#125; /// &lt;summary&gt; /// 苹果工厂类 /// &lt;/summary&gt; public class AppleFactory:FruitFactory &#123; public override Fruit CreateFruit() &#123; return new Apple(); &#125; &#125; /// &lt;summary&gt; /// 香蕉工厂类 /// &lt;/summary&gt; public class BananaFactory : FruitFactory &#123; public override Fruit CreateFruit() &#123; return new Banana(); &#125; &#125; /// &lt;summary&gt; /// 橘子工厂类 /// &lt;/summary&gt; public class OrangeFactory : FruitFactory &#123; public override Fruit CreateFruit() &#123; return new Orange(); &#125; &#125; /// &lt;summary&gt; /// 水果抽象类 /// &lt;/summary&gt; public abstract class Fruit &#123; /// &lt;summary&gt; /// 水果抽象方法 /// &lt;/summary&gt; public abstract void PrintName(); &#125; /// &lt;summary&gt; /// 苹果类 /// &lt;/summary&gt; public class Apple : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is an apple."); &#125; &#125; /// &lt;summary&gt; /// 香蕉类 /// &lt;/summary&gt; public class Banana : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is a banana"); &#125; &#125; /// &lt;summary&gt; /// 橘子类 /// &lt;/summary&gt; public class Orange : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is a orange"); &#125; &#125;&#125; 通过上面的修改可以发现，当再次增加一个新的产品时，原来的代码不需要进行修改，只需要新增该产品类和对应的工厂类即可。 总结使用场景a. 针对同一种类多个产品的生产与消费的解耦，满足开放关闭原则。 优点避免简单工厂类不易扩展与工厂类业务逻辑复杂的缺陷缺点当多个产品打包后的产品族需要进行扩展时，则显无能为力。即横向单个产品的扩展方便，纵向产品族扩展复杂 针对此缺点引入设计模式-抽象工厂模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式-简单工厂模式]]></title>
    <url>%2F2018%2F01%2F10%2FSimpleFactoryPattern%2F</url>
    <content type="text"><![CDATA[简单工厂模式一句话：一个产品抽象类，一个工厂类，这个工厂生产多个产品。 设计模式对编写代码的帮助是不言而喻的，有必要在学习的基础上做一些笔记。工厂类应用场景一般为创建对象。根据场景需求的不同，可以一般分为简单工厂模式（静态工厂）、工厂方法模式、抽象工厂模式。本篇内容只针对简单工厂模式。 一般情况下，如果需要实例化一个对象，那么就要new一个对象如下：1234567891011121314151617181920212223242526272829303132333435363738using System;namespace SettingPattern4&#123; class Customer &#123; static void Main(string[] args) &#123; //实例化苹果和香蕉 Apple apple = new Apple(); apple.PrintName(); Banana banana = new Banana(); banana.PrintName(); Console.Read(); &#125; &#125; /// &lt;summary&gt; /// 苹果类 /// &lt;/summary&gt; public class Apple &#123; public void PrintName() &#123; Console.WriteLine("This is an apple."); &#125; &#125; /// &lt;summary&gt; /// 香蕉类 /// &lt;/summary&gt; public class Banana &#123; public void PrintName() &#123; Console.WriteLine("This is a banana"); &#125; &#125;&#125; 十分简单的代码，顾客想要一个苹果和一个香蕉，那么他就自己初始化一个苹果和一个香蕉就好。 问题提出：顾客不关心水果是怎么创建的，只需要最后把水果给他就好，如何做能将顾客与水果关系解耦？ 解决办法：a.抽象水果类，所有的水果都继承该类;b.工厂类，静态方法生成对应的水果对象；c.顾客想要什么水果，给工厂类的方法传入水果名称就好； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;namespace SettingPattern4&#123; class Customer &#123; static void Main(string[] args) &#123; //实例化苹果和香蕉 Fruit first = FruitFactory.CreateFruit("Apple"); first.PrintName(); Console.WriteLine("-------------"); Fruit second = FruitFactory.CreateFruit("Banana"); second.PrintName(); Console.Read(); &#125; &#125; /// &lt;summary&gt; /// 水果工厂类 /// &lt;/summary&gt; public class FruitFactory &#123; /// &lt;summary&gt; /// 静态水果生产方法 /// &lt;/summary&gt; /// &lt;param name="fruitName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Fruit CreateFruit(string fruitName) &#123; Fruit result; switch (fruitName) &#123; case "Apple": result = new Apple(); break; case "Banana": result = new Banana(); break; default: result = new Apple();//未找到返回一个苹果 break; &#125; return result; &#125; &#125; /// &lt;summary&gt; /// 水果抽象类 /// &lt;/summary&gt; public abstract class Fruit &#123; /// &lt;summary&gt; /// 水果抽象方法 /// &lt;/summary&gt; public abstract void PrintName(); &#125; /// &lt;summary&gt; /// 苹果类 /// &lt;/summary&gt; public class Apple : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is an apple."); &#125; &#125; /// &lt;summary&gt; /// 香蕉类 /// &lt;/summary&gt; public class Banana : Fruit &#123; public override void PrintName() &#123; Console.WriteLine("This is a banana"); &#125; &#125;&#125; 可以看出，此时顾客并不知道如何去创建具体的水果对象，他只需要调用工厂创建水果方法并传入名称就能够获得对应水果对象。 总结使用场景a.使用者不关心产品对象是如何创建的，尤其是该对象创建工作十分繁琐;b.产品类别比较少的情况下;那么可以通过简单工厂模式将创建工作移入到工厂的静态类中 优点将产品与使用者进行一定程度的解耦。缺点不方便扩展，增加新的产品时，需要修改工厂类增加if-else产品分支，可能导致工厂类逻辑特别复杂。 针对此缺点引入设计模式-工厂方法模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018计划]]></title>
    <url>%2F2018%2F01%2F05%2F2018%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[计划分为两部分一、英语学习1、美语从头学a.调整学习方式，除了上下班以外，每天要最少抽出1个小时左右看书、复习、阅读（基本保证每天1课新学，其余时间复习）。2、扇贝a.保证打卡的同时，其余零星时间用来阅读英文简版书籍。二、软考a.先刷一遍视频。b.看计算题，刷真题。c.写范文的论文。 三、其他a.育儿b.专业方面]]></content>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2018%2F01%2F02%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先17年年初脑子一抽画了一个脑图，内容就是17年想要完成的事情，该计划只有开始时间和截止时间（2017-01-01至2017-12-31），其他详细执行计划则什么都没有，至于该计划最后能实现到什么程度，则可想而知了。 对于该计划，总的来说，作为第一个主动指定的年度计划，应该给与自己肯定，但是如何细化计划的实现步骤及改善完成的效果则是18年要改进的了。 脑图中关于专业的知识除了在工作中用到的需要零星学习之外，基本没有执行（惭愧惭愧），2017年总结下来，可以叫做我的英语学习元年。 赖世雄美语重头学全套从音标到高级共七本书。只在上下班途中学习，17年只学习了5本，中级下和高级未进行学习，此外已完成的5本中基本上属于草草了事，部分背过的文章和句子基本上也都忘记的差不多了。学以致用，未学好更别提用。 扇贝系列扇贝是从16年10月16日开始使用的，截止目前已连续打开800多天，2017年全年未曾断过，虽然有许多的水卡存在，但是我还是要给自己祝贺，此前从未有一件事能坚持如此之久。下面是参加扇贝2017年新年计划发的证书。英文简版图书（初高中水平）下面这些 其他英文学习APP除了扇贝，今年基本上把市面上常见学习软件都装了一遍，包括下面这些，基本都坚持使用最少3个月的时间。 学以致用Sitecore2017年花了这么多的时间精力，学英语，有什么用？本来打算自己学学，看美剧的时候可以看得更带劲，中文始终有翻译不到位的地方，而且眼睛是看字幕的，哪有时间看具体的人物表演啊。但是，世事难料，8月份直接一个sitecore的培训就下来了，全英文资料培训教材和考试，直接把我干蒙了。赶鸭子上架，没办法，硬着头皮上。最后把自己的第一本英文资料给看完了，把全英文的在线考试过了，对我而言真不容易。 失败中的失败软考高级集成项目工程师，这个确实是失败，当时想着能有时间好好复习备考，而实际计划总也赶不上变化，sitecore备考占用其中一部分时间，剩下的一部分时间则是自己东看看西玩玩就浪费掉了，150元就这么打水漂了。明年如何做，自己看着办。 最后18年总体计划，英语继续、专业加把劲、软考通过。 虽说计划赶不上变化，但是该有还得有，计划的目的不是为了逼着你必须要怎样，而是让你知道你目前的处境、状况，应该根据这个状况适时的调整自己，无论是学习还是生活，要活出深度，今年30了十分惭愧，活到这个年纪才体会到别人早早就已经知道的道理，2018加油。]]></content>
  </entry>
  <entry>
    <title><![CDATA[定时任务组件FluentScheduler]]></title>
    <url>%2F2017%2F12%2F19%2F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BB%84%E4%BB%B6FluentScheduler%2F</url>
    <content type="text"><![CDATA[定时任务组件FluentScheduler的基础使用方法 动态修改任务调用的间隔时间 FluentScheduler Github地址一般常用的方法，在它的github上面就可以找到api，这篇文章的demo主要实现的功能是通过修改appconfig文件内的配置信息，达到修改正在运行的任务时间，当然也可以增加自己的配置代码，如启动，暂停等等。 有一处要注意，修改appconfig文件后，读取时必须调用ConfigurationManager.RefreshSection(“appSettings”);否则会出现读取的值是缓存的情况，导致出错。 AppConfig文件如下12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&gt; &lt;/startup&gt; &lt;appSettings&gt; &lt;add key=&quot;ChangeStatus&quot; value=&quot;1&quot;/&gt; &lt;!--修改状态--&gt; &lt;add key=&quot;Interval&quot; value=&quot;5&quot;/&gt; &lt;!--间隔值--&gt; &lt;add key=&quot;IntervalType&quot; value=&quot;Seconds&quot;/&gt; &lt;!--间隔类型年、月、日、时、分、秒--&gt; &lt;add key=&quot;HoursOfDay&quot; value=&quot;23&quot;/&gt; &lt;!--间隔类型是天时的小时 取值0-23--&gt; &lt;add key=&quot;MinutesOfDay&quot; value=&quot;59&quot;/&gt; &lt;!--间隔类型是天时的分钟 取值0-59--&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 控制台应用程序源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System;using FluentScheduler;using System.Configuration;namespace FluentSchedulerDemo&#123; class Program &#123; static void Main(string[] args) &#123; //首次允许业务逻辑 JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(1).Seconds(); &#125;); //允许检查 JobManager.AddJob(CheckSchedule, t =&gt; &#123; t.WithName("CheckSchedule").ToRunEvery(10).Seconds(); &#125;); Console.ReadLine(); &#125; /// &lt;summary&gt; /// 定时检查配置文件，动态修改当前工作安排 /// &lt;/summary&gt; static void CheckSchedule() &#123; #region 读取appconfig配置文件 ConfigurationManager.RefreshSection("appSettings");//非常重要！！！刷新后才能读取到更改后的配置信息 int changeStatus = Convert.ToInt32(ConfigurationManager.AppSettings["ChangeStatus"]); int interval = Convert.ToInt32(ConfigurationManager.AppSettings["Interval"]); int hoursOfDay = Convert.ToInt32(ConfigurationManager.AppSettings["HoursOfDay"]); int minutesOfDay = Convert.ToInt32(ConfigurationManager.AppSettings["MinutesOfDay"]); string intervalType = ConfigurationManager.AppSettings["IntervalType"]; #endregion if (changeStatus == 1) &#123; //修改业务逻辑定时任务 JobManager.RemoveJob("ServiceLogic"); Console.WriteLine("CheckSchedule：" + DateTime.Now); #region 根据间隔的类型，修改任务计划时间 switch (intervalType) &#123; case "Seconds": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Seconds(); &#125;); break; case "Minutes": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Minutes(); &#125;); break; case "Hours": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Hours(); &#125;); break; case "Days": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Days().At(hoursOfDay, minutesOfDay); &#125;); break; case "Months": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Months(); &#125;); break; case "Years": JobManager.AddJob(ServiceLogic, t =&gt; &#123; t.WithName("ServiceLogic").ToRunEvery(interval).Years(); &#125;); break; &#125; #endregion //更新修改状态 Configuration configuration = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); configuration.AppSettings.Settings["ChangeStatus"].Value = "0"; configuration.Save(); &#125; &#125; /// &lt;summary&gt; /// 业务逻辑 /// &lt;/summary&gt; static void ServiceLogic() &#123; Console.WriteLine("ServiceLogic：" + DateTime.Now); //TODO: 实际的业务逻辑 &#125; &#125;&#125; 程序运行截图 总的来说一句话：使用两个任务计划，一个用来检查配置文件的状态，随时进行更改另一个业务任务计划的运行状态。]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除微信昵称中emoji字符]]></title>
    <url>%2F2017%2F12%2F18%2F%E5%8E%BB%E9%99%A4%E5%BE%AE%E4%BF%A1%E6%98%B5%E7%A7%B0%E4%B8%ADemoji%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[问题描述1、微信公众号获得用户基础信息时，用户的昵称nickname中可能包含emoji表情，而该表情在保存数据库之后在前台页面中使用（导出excel）会导致异常，因此需要该emoji表情去掉。解决方法：替换所有表情字符。 参考地址 1234567891011class Program &#123; static void Main(string[] args) &#123; string nickName = "特殊字符串"; nickName = Regex.Replace(nickName, @"\p&#123;Cs&#125;", "*").Replace("\"", "*"); Console.WriteLine(nickName); Console.ReadKey(); &#125; &#125;]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信公众号-发送文本消息]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E5%8F%91%E9%80%81%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[使用微信公众号，发送文本消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void SendNews(List&lt;dt_Mem&gt; memList,string appID,string appSecret,string message) &#123; openIDList = memList.Select(i =&gt; i.Fields["openid"].Value).ToList&lt;string&gt;(); var result = SendNews(appID, appSecret, message, openIDList); &#125; /// &lt;summary&gt; ///公众号发送文本信息 /// &lt;/summary&gt; /// &lt;param name="appID"&gt;&lt;/param&gt; /// &lt;param name="appSecret"&gt;&lt;/param&gt; /// &lt;param name="message"&gt;&lt;/param&gt; /// &lt;param name="openIDList"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string SendMessage(string appID, string appSecret, string message, List&lt;string&gt; openIDList) &#123; if (openIDList.Count == 1) &#123; openIDList.Add(" "); &#125; string requestURL = "https://api.weixin.qq.com/cgi-bin/message/mass/send?access_token=&#123;0&#125;"; string openIDString = string.Join(",", openIDList.Select(i =&gt; "\"" + i + "\"")); string temp = "&#123;\"touser\": [" + openIDString + "]," + "\"msgtype\": \"text\", " + "\"text\": &#123;\"content\":\"" + message + "\"&#125; " + "&#125;"; //预览接口开发用 string urlName = "您好，这里是为您推荐的链接地址" + message.Substring(message.LastIndexOf("/") + 1); message = "&lt;a href='" + message + "'&gt;" + urlName + "&lt;/a&gt;"; requestURL = " https://api.weixin.qq.com/cgi-bin/message/mass/preview?access_token=&#123;0&#125;"; temp = "&#123;\"touser\": \"oEWyxv6y7JEuHISt50hQCjrLGHrk\"," + "\"msgtype\": \"text\", " + "\"text\": &#123;\"content\":\"" + message + "\"&#125; " + "&#125;"; string strJson = HttpRequestUtil.RequestUrl(string.Format(requestURL, GetAccess_token(appID, appSecret)), "POST", temp); return strJson; &#125; /// &lt;summary&gt; /// 获得基础接口的access_token /// &lt;/summary&gt; /// &lt;param name="appID"&gt;&lt;/param&gt; /// &lt;param name="appSecret"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetAccess_token(string appID, string appSecret) &#123; string access_token = ""; CacheManage cache = CacheManage.Instance; if (cache.Contains("access_token" + appID)) &#123; access_token = cache.Get("access_token" + appID) as string; &#125; else &#123; string strJson = ""; string requestURL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;0&#125;&amp;secret=&#123;1&#125;"; strJson = HttpRequestUtil.RequestUrl(string.Format(requestURL, appID, appSecret)); access_token = Tools.GetJsonValue(strJson, "access_token"); double cacheMinutes = (double)(Convert.ToInt32(Tools.GetJsonValue(strJson, "expires_in")) / 60);//将秒转换为分钟 cache.Set("access_token" + appID, access_token, cacheMinutes); &#125; return access_token; &#125;]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>发送消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.NET防止SQL注入]]></title>
    <url>%2F2017%2F12%2F05%2FNET%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[问题描述：测试人员通过IBM appscan工具进行网站系统扫描，发现SQL注入漏洞，如何能进行全局性的修改，将所有请求的内容进行过滤？ 解决办法：通过全局应用程序类，将所有的请求进行敏感字过滤。 1、Global.asax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using MxWeiXinPF.Common;using System;namespace MxWeiXinPF.Web&#123; public class Global : System.Web.HttpApplication &#123; protected void Application_Start(object sender, EventArgs e) &#123; &#125; protected void Session_Start(object sender, EventArgs e) &#123; &#125; protected void Application_BeginRequest(object sender, EventArgs e) &#123; if (Request.Cookies != null) &#123; if (SafeHelper.CookieData()) &#123; Response.Write("您提交的Cookie数据有恶意字符！"); Response.End(); &#125; &#125; if (Request.UrlReferrer != null) &#123; if (SafeHelper.referer()) &#123; Response.Write("您提交的Referrer数据有恶意字符！"); Response.End(); &#125; &#125; if (Request.RequestType.ToUpper() == "POST") &#123; if (SafeHelper.PostData()) &#123; Response.Write("您提交的Post数据有恶意字符！"); Response.End(); &#125; &#125; if (Request.RequestType.ToUpper() == "GET") &#123; if (SafeHelper.GetData()) &#123; Response.Write("您提交的Get数据有恶意字符！"); Response.End(); &#125; &#125; &#125; protected void Application_AuthenticateRequest(object sender, EventArgs e) &#123; &#125; protected void Application_Error(object sender, EventArgs e) &#123; &#125; protected void Session_End(object sender, EventArgs e) &#123; &#125; protected void Application_End(object sender, EventArgs e) &#123; &#125; &#125;&#125; 2、SafeHelper.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Text.RegularExpressions;using System.Web;namespace MxWeiXinPF.Common&#123; public class SafeHelper &#123; private const string StrRegex = @"\b(alert|confirm|prompt)\b|^\+/v(8|9)|\b(and|or)\b.&#123;1,6&#125;?(=|&gt;|&lt;|\bin\b|\blike\b)|/\*.+?\*/|&lt;\s*script\b|&lt;\s*img\b|\bEXEC\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\s+(TABLE|DATABASE)"; public static bool PostData() &#123; bool result = false; for (int i = 0; i &lt; HttpContext.Current.Request.Form.Count; i++) &#123; result = CheckData(HttpContext.Current.Request.Form[i].ToString()); if (result) &#123; break; &#125; &#125; return result; &#125; public static bool GetData() &#123; bool result = false; for (int i = 0; i &lt; HttpContext.Current.Request.QueryString.Count; i++) &#123; result = CheckData(HttpContext.Current.Request.QueryString[i].ToString()); if (result) &#123; break; &#125; &#125; return result; &#125; public static bool CookieData() &#123; bool result = false; for (int i = 0; i &lt; HttpContext.Current.Request.Cookies.Count; i++) &#123; result = CheckData(HttpContext.Current.Request.Cookies[i].Value.ToLower()); if (result) &#123; break; &#125; &#125; return result; &#125; public static bool referer() &#123; bool result = false; return result = CheckData(HttpContext.Current.Request.UrlReferrer.ToString()); &#125; public static bool CheckData(string inputData) &#123; if (Regex.IsMatch(inputData, StrRegex)) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密解密(c#与js版)]]></title>
    <url>%2F2017%2F11%2F29%2FRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86-c-%E4%B8%8Ejs%E7%89%88%2F</url>
    <content type="text"><![CDATA[业务描述：前端js使用私有秘钥将数据进行加密，后端C#在一般处理程序中使用公钥对加密数据进行解密。两个版本的实现，版本一可直接使用，版本二可用来参考如何将XML秘钥与PEM秘钥的转换。 版本一描述：1、该版本实现用户登录过程中RSA加密验证的过程。2、前台JS进行加密，后台从session中获得私钥进行解密。3、RSA秘钥保存在session中，刷新登录页面后自动更新。 版本二描述：1、C#自有类RSACryptoServiceProvider生成RSA的秘钥与公钥的方法ToXmlString(true)秘钥，ToXmlString(false)公钥，结果是XML形式的，js无法直接使用，js所使用的是PEM形式的秘钥。解决方法：使用工具类bouncycastle直接生成PEM版的秘钥和公钥，后台使用时，再将秘钥转换为XML版的。引用地址：https://www.bouncycastle.org/插件下载地址：https://downloads.bouncycastle.org/csharp/bccrypto-csharp-1.8.1-bin.zip 2、js加密数据后base64位的数据在传输中“+”号会变为空格，导致后台C#解密出错。解决方法：js先加号转后，然后后台再将加号转回。 3、网页版的加密解密demo以固定的秘钥形式来实现，实际案例中可以考虑更改为使用session保存针对单个用户来生成的公钥和秘钥。 参考地址：http://www.sufeinet.com/forum.php?mod=viewthread&amp;tid=5484&amp;highlight=RSAhttps://www.cnblogs.com/Leo_wl/p/5763243.html 控制台应用程序RSA基础代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using Org.BouncyCastle.Asn1.Pkcs;using Org.BouncyCastle.Asn1.X509;using Org.BouncyCastle.Crypto;using Org.BouncyCastle.Crypto.Generators;using Org.BouncyCastle.Crypto.Parameters;using Org.BouncyCastle.Pkcs;using Org.BouncyCastle.Security;using Org.BouncyCastle.X509;using System;using System.Security.Cryptography;using System.Text;namespace RSAGenerateKey&#123; class Program &#123; static void Main(string[] args) &#123; RsaKeyPairGenerator g = new RsaKeyPairGenerator(); g.Init(new KeyGenerationParameters(new SecureRandom(), 1024)); var pair = g.GenerateKeyPair(); PrivateKeyInfo privateKeyInfo = PrivateKeyInfoFactory.CreatePrivateKeyInfo(pair.Private); byte[] serializedPrivateBytes = privateKeyInfo.ToAsn1Object().GetDerEncoded(); string serializedPrivate = Convert.ToBase64String(serializedPrivateBytes);//PEM秘钥 SubjectPublicKeyInfo publicKeyInfo = SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(pair.Public); byte[] serializedPublicBytes = publicKeyInfo.ToAsn1Object().GetDerEncoded(); string serializedPublic = Convert.ToBase64String(serializedPublicBytes);//PEM公钥 RsaPrivateCrtKeyParameters privateKey = (RsaPrivateCrtKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(serializedPrivate)); RsaKeyParameters publicKey = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(serializedPublic)); RSACryptoServiceProvider rcsp = new RSACryptoServiceProvider(); RSAParameters parms = new RSAParameters(); //So the thing changed is offcourse the ToByteArrayUnsigned() instead of //ToByteArray() parms.Modulus = privateKey.Modulus.ToByteArrayUnsigned(); parms.P = privateKey.P.ToByteArrayUnsigned(); parms.Q = privateKey.Q.ToByteArrayUnsigned(); parms.DP = privateKey.DP.ToByteArrayUnsigned(); parms.DQ = privateKey.DQ.ToByteArrayUnsigned(); parms.InverseQ = privateKey.QInv.ToByteArrayUnsigned(); parms.D = privateKey.Exponent.ToByteArrayUnsigned(); parms.Exponent = privateKey.PublicExponent.ToByteArrayUnsigned(); //So now this now appears to work. rcsp.ImportParameters(parms); string s = rcsp.ToXmlString(true); string privateKeyXmlText = rcsp.ToXmlString(true);//XML秘钥 string publicKeyXmlText = rcsp.ToXmlString(false);//XML公钥 //加密解密 string texta1 = "abc",texta2="",textb1=""; byte[] cipherbytes; cipherbytes = rcsp.Encrypt(Encoding.UTF8.GetBytes(texta1), false); texta2 = Convert.ToBase64String(cipherbytes); cipherbytes = rcsp.Decrypt(Convert.FromBase64String(texta2), false); textb1= Encoding.UTF8.GetString(cipherbytes); Console.Read(); &#125; &#125;&#125; 版本一 版本一： 直接使用RSACryptoServiceProvider类生成xml的公钥和秘钥，放入session中该版本用到了四个js。下载地址：https://pan.baidu.com/s/1boQox8V1234&lt;script src="Scripts/jquery-1.4.1.js"&gt;&lt;/script&gt;&lt;script src="Scripts/Barrett.js"&gt;&lt;/script&gt;&lt;script src="Scripts/BigInt.js"&gt;&lt;/script&gt;&lt;script src="Scripts/RSA.js"&gt;&lt;/script&gt; 前台代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Login.aspx.cs" Inherits="RSAWeb.Login" %&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head runat="server"&gt; &lt;title&gt;登录页RSA加密解密demo&lt;/title&gt; &lt;script src="Scripts/jquery-1.4.1.js"&gt;&lt;/script&gt; &lt;script src="Scripts/Barrett.js"&gt;&lt;/script&gt; &lt;script src="Scripts/BigInt.js"&gt;&lt;/script&gt; &lt;script src="Scripts/RSA.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function cmdEncrypt() &#123; //关键步骤 setMaxDigits(129); var key = new RSAKeyPair("&lt;%=strPublicKeyExponent%&gt;", "", "&lt;%=strPublicKeyModulus%&gt;"); var pwdMD5Twice = $("#txtPassword").attr("value"); var pwdRtn = encryptedString(key, pwdMD5Twice); //关键步骤 $("#encrypted_pwd").attr("value", pwdRtn); $("#formLogin").submit(); return; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="Login.aspx" id="formLogin" method="post"&gt; &lt;div&gt; &lt;div&gt; User Name: &lt;/div&gt; &lt;div&gt; &lt;input id="txtUserName" name="txtUserName" value="&lt;%=postbackUserName%&gt;" type="text" maxlength="16" /&gt; &lt;/div&gt; &lt;div&gt; Password: &lt;/div&gt; &lt;div&gt; &lt;input id="txtPassword" type="password" maxlength="16" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id="btnLogin" type="button" value="Login" onclick="return cmdEncrypt()" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="hidden" name="encrypted_pwd" id="encrypted_pwd" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;div&gt; &lt;%=LoginResult%&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后台代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System;using System.Security.Cryptography;using System.Text;namespace RSAWeb&#123; public partial class Login : System.Web.UI.Page &#123; protected string strPublicKeyExponent = ""; protected string strPublicKeyModulus = ""; protected string LoginResult = ""; protected string postbackUserName = ""; protected void Page_Load(object sender, EventArgs e) &#123; LoginResult = ""; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); if (string.Compare(Request.RequestType, "get", true) == 0) &#123; //将私钥存Session中 Session["private_key"] = rsa.ToXmlString(true); CYQ.Data.Log.WriteLogToTxt(Convert.ToString(Session["private_key"]), CYQ.Data.LogType.Debug); &#125; else &#123; bool bLoginSucceed = false; try &#123; string strUserName = Request.Form["txtUserName"]; postbackUserName = strUserName; string strPwdToDecrypt = Request.Form["encrypted_pwd"]; rsa.FromXmlString((string)Session["private_key"]); byte[] result = rsa.Decrypt(HexStringToBytes(strPwdToDecrypt), false); System.Text.ASCIIEncoding enc = new ASCIIEncoding(); string strPwdMD5 = enc.GetString(result); if (string.Compare(strUserName, "admin", true) == 0 &amp;&amp; string.Compare(strPwdMD5, "admin", true) == 0)//14e1b600b1fd579f47433b88e8d85291 bLoginSucceed = true; &#125; catch (Exception) &#123; &#125; if (bLoginSucceed) LoginResult = "登录成功"; else LoginResult = "登录失败"; &#125; //把公钥适当转换，准备发往客户端 RSAParameters parameter = rsa.ExportParameters(true); strPublicKeyExponent = BytesToHexString(parameter.Exponent); strPublicKeyModulus = BytesToHexString(parameter.Modulus); &#125; private string BytesToHexString(byte[] input) &#123; StringBuilder hexString = new StringBuilder(64); for (int i = 0; i &lt; input.Length; i++) &#123; hexString.Append(String.Format("&#123;0:X2&#125;", input[i])); &#125; return hexString.ToString(); &#125; public static byte[] HexStringToBytes(string hex) &#123; if (hex.Length == 0) &#123; return new byte[] &#123; 0 &#125;; &#125; if (hex.Length % 2 == 1) &#123; hex = "0" + hex; &#125; byte[] result = new byte[hex.Length / 2]; for (int i = 0; i &lt; hex.Length / 2; i++) &#123; result[i] = byte.Parse(hex.Substring(2 * i, 2), System.Globalization.NumberStyles.AllowHexSpecifier); &#125; return result; &#125; &#125;&#125; 版本二 版本二： 未能解决问题：在使用过程中偶尔会出现无法解密的异常，用户a8176a4c-5b7e-4f1d-94d8-04e744332f76进行分数/H544nYvvBRPZQAIQfDGHMySy/svCbS8/uUwwv5Fc6hKlTed9XvwuEYeAKv22cdPXDV%2B6/tmduEuVJDCP7G8Jb2TxJdN9A%2Bwou%2BGnOTO7%2BTo6yA2KX4Uvriof5yCt1ONmkLbsPRVh0/cnjnogJwLk2U/FVggjIhcOP6Rq%2BzLOw==的提交操作,发生异常不正确的数据。本地直接使用测试demo可以解密，所以无法找到出问题的原因。！！！！ 2、网页版本webform 前台网页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="login.aspx.cs" Inherits="RSADemo.login" %&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head runat="server"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/jquery.js"&gt;&lt;/script&gt; &lt;script src="http://passport.cnblogs.com/scripts/jsencrypt.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/node-forge@0.7.0/dist/forge.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; //pem公钥 var pemPublicKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHCkaSCVy6sHB/5rAKS/1EEtyzWuy30gLyrpNbFI3GtpsdFGdsqQ/uwiscGD+pZ7Mxj1ZumPs4jHvPpcAeCb8gKsqP/f5+pputTMuTkhTQqlDT1plHR7w3REQI8MaJ8KTA/pJiPo6iWToFynQeJNWjicxXxNURSZQ7nmC2rl4uPQIDAQAB"; $("#tra").val(pemPublicKey); var encrypt = new JSEncrypt(); encrypt.setPublicKey($("#tra").val()); var data = encrypt.encrypt("123456789"); alert(data); $("#btn").click(function () &#123; $.ajax(&#123; url: 'Handler1.ashx', data: "pwd=" +encodeURI(data).replace(/\+/g, '%2B'), //+号的处理：因为数据在网络上传输时，非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，而base64编码在传输到后端的时候，+会变成空格，因此先替换掉。后端再替换回来 type: 'post', success: function (msg) &#123; alert(msg); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="form1" runat="server"&gt; &lt;div&gt; &lt;input type="button" id="btn" value="点我" /&gt; &lt;textarea id="tra" rows="15" cols="65"&gt; &lt;/textarea&gt; &lt;hr /&gt; 注意+好的处理 &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台ashx一般处理程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Security.Cryptography;using System.Text;using System.Web;namespace RSADemo&#123; /// &lt;summary&gt; /// Summary description for Handler1 /// &lt;/summary&gt; public class Handler1 : IHttpHandler &#123; public void ProcessRequest(HttpContext context) &#123; string result = ""; //XML密钥 string privateKey = @"&lt;RSAKeyValue&gt;&lt;Modulus&gt;xwpGkglcurBwf+awCkv9RBLcs1rst9IC8q6TWxSNxrabHRRnbKkP7sIrHBg/qWezMY9Wbpj7OIx7z6XAHgm/ICrKj/3+fqabrUzLk5IU0KpQ09aZR0e8N0RECPDGifCkwP6SYj6Oolk6Bcp0HiTVo4nMV8TVEUmUO55gtq5eLj0=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/LnrFrusoNklOl6d0zSWZ1aCdQC2l3XXU8SSgYNLuSmgVwl7wQ2w0Jn9SQqyiVRmbcp1SX28/bH6TaA2v9ejHQ==&lt;/P&gt;&lt;Q&gt;yZ5TTtLOfTqrikYjy/fyktTk977y2GG2R9sgNPHtnH5EIIC9CoJETDwfSu40YUlHeUUXHQ1nG1WmWbEOC76toQ==&lt;/Q&gt;&lt;DP&gt;5UfC+YfgkLkQJklqxA+EmFIK3x17iiO16+B9zhQQ4fba6bvH05iZHldmTBrxaNfyaY7xI3B4wmzymfRNV3TKHQ==&lt;/DP&gt;&lt;DQ&gt;k7EvRaaXLJU14+zNfDT9tSHPOMzgCDJL3Qdf6GjwrpqwPT8RPAmBDndcVP95z2pmuScrb1TKGvP7D+jraR8dAQ==&lt;/DQ&gt;&lt;InverseQ&gt;4gbDpW7ca3dn0XXPkYsVmIl7SBqU8lq9X2xji/Nyg1M0pjDcpdQm0bqOm+/5usQl+kRotpIoK+Yf6J++zbmNjg==&lt;/InverseQ&gt;&lt;D&gt;Ccxfc356/mTDsQQv+93ISsLb8wdhml4AD6bY8bWmEhd4tNqFieObuW79FM27ypDkkSbDhD/LNDo0OSFpfwEPU8VxnEMzFnVw7MIWGSVKWocZHIhsclkHtHNtHaKS0LNEie2q0PGMiIYty/QG5k3bJeA8R42teXv3nARYEgzuNmE=&lt;/D&gt;&lt;/RSAKeyValue&gt;"; try &#123; string pwd = context.Request["pwd"]; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privateKey); //把+号，再替换回来 cipherbytes = rsa.Decrypt(Convert.FromBase64String(pwd.Replace("%2B", "+")), false); result = Encoding.UTF8.GetString(cipherbytes); &#125; catch (Exception exception) &#123; &#125; context.Response.Write(result); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流操作]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%B5%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C#常用流操作 文件流 FileStream流读取器 StreamReader流写入器 StreamWriter 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;namespace FileStreamStudy&#123; class Program &#123; static void Main(string[] args) &#123; // 文件流和读取写入器操作完后，需要调用close()方法进行关闭 //读文件流 using (FileStream stream = new FileStream("D:\\license.xml", FileMode.OpenOrCreate))//文件地址，文件读取模式FileMode枚举类 &#123; //流读取器 using (StreamReader reader = new StreamReader(stream)) &#123; string currentLine = reader.ReadLine();//读取一行 while (!string.IsNullOrEmpty(currentLine)) &#123; Console.WriteLine(currentLine); currentLine = reader.ReadLine(); &#125; &#125; &#125; //写文件流 using (FileStream stream = new FileStream("d:\\1.txt", FileMode.Append)) &#123; //流写入器 using (StreamWriter writer = new StreamWriter(stream)) &#123; string s = "12345"; writer.WriteLine(s); writer.Flush();//清空缓存 &#125; &#125; Console.Read(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml序列化]]></title>
    <url>%2F2017%2F08%2F16%2Fxml%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[可能目前系统之间接口多数以JSON或者XML形式进行数据的传输，项目中用到了XML，但是没有使用下面介绍的以序列化的形式将XML与对象进行互转，当时为了多个实现方案所以做了一些准备，先总结XML序列化与反序列化的使用基础，备用吧。 基础类及基础方法 代码实现 总结及出现的问题 基础类及基础方法 基础类主要是：System.Xml.Serialization.XmlSerializerXmlSerializer类主要功能是将对象和XML文档之间进行序列化和发序列化。XmlSerializer可以方便将对象编码为XML。 1、构造器创建XmlSerializer对象12//创建新实例并指定改实例可以用来序列化和反序列化的类的类型XmlSerializer xmlSerializer=new XmlSerializer(Type); 2、XmlSerializer对象序列化对象12//将对象Object序列化到TextWriter中xmlSerializer.Serialize(TextWriter,Object); TextWriter是一个有序序列字符的编写器，它是一个抽象类，常用的有两个子类即：StreamWriter（写入流） 和 StringWriter（写入字符串）.因此在实际使用时，这里选择System.IO.StringWriter。 这里需要注意，如果要指定序列化后XML的编码类型，StringWriter有一个属性Encoding,但是该属性只读，无法进行设置，因此需要写一个子类来覆盖Encoding的属性。 123456789public sealed class Utf8StringWriter : StringWriter &#123; //指定编码类型是UTF-8 public override Encoding Encoding &#123; get &#123; return Encoding.UTF8; &#125; &#125; &#125; //将对象Object序列化到TextWriter的子类Utf8StringWriter中xmlSerializer.Serialize(Utf8StringWriter,Object); 3、获得序列化后的结果1string XMLResult=Utf8StringWriter.ToString(); 4、通过特性Attritube设置自定义类的序列化结果System.Xml.Serialization命名空间中有一系列的特性类，用来控制复杂类型序列化的控制。例如XmlElementAttribute、XmlAttributeAttribute、XmlArrayAttribute、XmlArrayItemAttribute、XmlRootAttribute等等。序列化帮助 代码实现完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149using System;using System.IO;using System.Reflection;using System.Text;using System.Xml;using System.Xml.Serialization;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; SERVICE service = new SERVICE(); HEAD head = service.HEAD; head.nsrsbh = "140115728183815"; head.serviceversion = "1.3"; head.serviceid = "jy.dzptfpkj"; head.iszip = "N"; head.encryptcode = "0"; head.issyn = "Y"; service.Cmd = new Cmd[] &#123;new Cmd(),new Cmd() &#125;; //序列化这个对象 XmlSerializer serializer = new XmlSerializer(service.GetType()); using (Utf8StringWriter writer = new Utf8StringWriter()) &#123; serializer.Serialize(writer, service); Console.WriteLine(writer.ToString()); &#125; Console.Read(); &#125; &#125; public class BaseObject &#123; public BaseObject() &#123; Type t = this.GetType();//构造器获得当前类型 PropertyInfo[] list=t.GetProperties();//获得所有属性 foreach (PropertyInfo item in list) &#123; object[] objAttrs = item.GetCustomAttributes(typeof(XmlElementAttribute), true);//获得所有XmlElement特性 if (objAttrs != null &amp;&amp; objAttrs.Length &gt; 0) &#123; XmlElementAttribute attr = objAttrs[0] as XmlElementAttribute; //Console.WriteLine(attr.ElementName); attr.IsNullable = true;//将特性设置为可空 &#125; if (IsType(item.PropertyType, "System.String")) &#123; item.SetValue(this, string.Empty, null);//将字符串类型属性的值设置为空字符串 &#125; &#125; &#125; /// &lt;summary&gt; /// 类型匹配 /// &lt;/summary&gt; /// &lt;param name="type"&gt;&lt;/param&gt; /// &lt;param name="typeName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsType(Type type, string typeName) &#123; if (type.ToString() == typeName) return true; if (type.ToString() == "System.Object") return false; return IsType(type.BaseType, typeName); &#125; &#125; [XmlRoot("SERVICE")] public class SERVICE: BaseObject &#123; public SERVICE() &#123; this.HEAD = new HEAD(); &#125; [XmlElement("HEAD")] public HEAD HEAD &#123; get; set; &#125; [XmlArray("BODY")] [XmlArrayItem("cmd")] public Cmd[] Cmd &#123; get; set; &#125; &#125; public class HEAD : BaseObject &#123; public HEAD() &#123; this.RTNINF = new RTNINF(); &#125; [XmlElement("nsrsbh")] public string nsrsbh &#123; get; set; &#125; [XmlElement("serviceversion")] public string serviceversion &#123; get; set; &#125; [XmlElement("serviceid")] public string serviceid &#123; get; set; &#125; [XmlElement("iszip")] public string iszip &#123; get; set; &#125; [XmlElement("encryptcode")] public string encryptcode &#123; get; set; &#125; [XmlElement("issyn")] public string issyn &#123; get; set; &#125; [XmlElement("RTNINF")] public RTNINF RTNINF &#123; get; set; &#125; &#125; public class RTNINF : BaseObject &#123; [XmlElement("rtn_code")] public string rtn_code &#123; get; set; &#125; [XmlElement("rtn_reason")] public string rtn_reason &#123; get; set; &#125; &#125; public sealed class Utf8StringWriter : StringWriter &#123; public override Encoding Encoding &#123; get &#123; return Encoding.UTF8; &#125; &#125; &#125; public class Cmd : BaseObject &#123; [XmlElement("productid")] public string ProductId &#123; get; set; &#125; [XmlElement("price")] public string Price &#123; get; set; &#125; [XmlElement("date")] public string Date &#123; get; set; &#125; [XmlElement("state")] public string State &#123; get; set; &#125; [XmlElement("type")] public string Type &#123; get; set; &#125; &#125; &#125; 总结问题1、项目需要，所有的对象属性都要生成XML，即如果属性是空值，默认序列化XML后不会显示，所以把所有对象都继承自BaseObject类下，再使用BaseObject类的构造器通过反射子类中特性的方法，在初始化子类时，将空字符串写入，这样最后生成XML文件时，空字符串的属性也会显示了。 反射时使用了的类及方法包括Object.GetType()根据对象获得类型,Type.GetProperties()根据类型获得说有属性,PropertyInfo.GetCustomAttributes根据属性获得所有特性，父类BaseObject 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940 public class BaseObject&#123; public BaseObject() &#123; Type t = this.GetType();//构造器获得当前类型 PropertyInfo[] list=t.GetProperties();//反射获得所有属性 foreach (PropertyInfo item in list) &#123; object[] objAttrs = item.GetCustomAttributes(typeof(XmlElementAttribute), true);//获得所有XmlElement特性 if (objAttrs != null &amp;&amp; objAttrs.Length &gt; 0) &#123; XmlElementAttribute attr = objAttrs[0] as XmlElementAttribute; //Console.WriteLine(attr.ElementName); attr.IsNullable = true;//将特性设置为可空 &#125; if (IsType(item.PropertyType, "System.String")) &#123; item.SetValue(this, string.Empty, null);//将字符串类型属性的值设置为空字符串 &#125; &#125; &#125; /// &lt;summary&gt; /// 类型匹配 /// &lt;/summary&gt; /// &lt;param name="type"&gt;&lt;/param&gt; /// &lt;param name="typeName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsType(Type type, string typeName) &#123; if (type.ToString() == typeName) return true; if (type.ToString() == "System.Object") return false; return IsType(type.BaseType, typeName); &#125;&#125; 2、SERVICE类下的Cmd属性比较特殊，它是一个数组，通过XmlArray特性和XmlArrayItem特性配合使用后，如下： [XmlArray(“BODY”)] [XmlArrayItem(“cmd”)] public Cmd[] Cmd { get; set; } 序列化XML后生成的效果如下： 123456&lt;BODY&gt; &lt;cmd&gt;&lt;/cmd&gt; &lt;cmd&gt;&lt;/cmd&gt; &lt;cmd&gt;&lt;/cmd&gt; &lt;cmd&gt;&lt;/cmd&gt;&lt;/BODY&gt;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信公众号集合支付宝支付]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%9B%86%E5%90%88%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[微信公众号集合支付宝支付 支付宝支付有多种方式，其中手机网站支付满足微信公众号内集成的要求，所以这篇文章即同时描述支付宝手机网站支付。 配置基础信息 API及业务逻辑 代码实现 总结及出现的问题 配置基础信息 [x] 给企业注册支付宝账号 [x] 创建自用型应用 [x] 添加并签约手机网站支付需要首先在网站内签约开通手机网站支付的权限。 API及业务逻辑手机网站支付API可以前往以下网址查看及下载sdk：目前手机网站支付demo有： JAVA和PHP版本SDK则有：JAVA、.NET和PHP版本 手机支付APISDK下载微信公众号集成帮助包签名sign生成规则代码实现###普通手机网站用户进行确认下单页面 12345678910111213141516171819202122232425262728293031323334353637383940414243 namespace AliPayDemo&#123; public partial class Pay : System.Web.UI.Page &#123; //不是真实数据 string APPID = "2017090907474487";//应用ID //应用私钥 string APP_PRIVATE_KEY = @"****JEwKBgQCIFY+12QuI3gI478vsixJiYOWJb2T7MRr0Zlg2n3fnQWnVB2gOkSgls/CHM3y+d/GQRJRE5aFWa2Xt"; //支付宝公钥 string ALIPAY_PUBLIC_KEY = @"***PXZOf8eQx+qWGky6LJZWie4IF2oqY7El1nps2qVg1IbQkDdIMNSr2a2nQF5GwSpVcF7bRZeNG2qgs3EjHu4hGqXMWbg6Fvs1iigiBYfkzQIDAQAB"; string CHARSET = "utf-8";//编码格式 protected void Page_Load(object sender, EventArgs e) &#123; //SDK已经封装掉了公共参数，只需要初始化一次 IAopClient client = new DefaultAopClient("https://openapi.alipay.com/gateway.do", APPID, APP_PRIVATE_KEY, "json", "1.0", "RSA2", ALIPAY_PUBLIC_KEY, CHARSET, false); //实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称如：alipay.trade.wap.pay.request AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); //SDK已经封装掉了公共参数，这里只需要传入业务参数 //此次只是参数展示，未进行字符串转义，实际情况下请转义 //注意value类型，如金额没有引号， request.BizContent = "&#123;" + " \"subject\":\"大乐透\"," + " \"out_trade_no\":\"70501111111S0011111191\"," + " \"total_amount\":0.01," + " \"product_code\":\"QUICK_WAP_WAY\"" + " &#125;"; AlipayTradeWapPayResponse response = client.pageExecute(request); divBody.InnerHtml = response.Body; ////调用成功，则处理业务逻辑 //if (response.IsError) //&#123; // //..... //&#125; &#125; &#125;&#125; ###微信公众号内用户进行确认下单页面1、下载集成微信公众号的帮助包并将文件放入项目文件夹中 ap.js 跳转到自带浏览器js pay.htm 提示用户跳转htm页面1、使用pageExecute方法，以GET方式获得url字符串；12AlipayTradeWapPayResponse response = client.pageExecute(request,null,&quot;GET&quot;); test = response.Body; 2、将Url传入前台页面标签，待用户点击确定1&lt;a id="test" href="&lt;%=test%&gt;" class="button button-big button-fill"&gt;支付宝结算&lt;/a&gt; 3、用户点击页面后跳转到提示页，提示用户使用手机自带浏览器打开连接 4、完成支付 5、整体的代码 前端123456789101112131415161718192021222324252627282930313233 &lt;%@ Page Language="C#" AutoEventWireup="true" CodeFile="JsApiPayPage1.aspx.cs" Inherits="JsApiPayPage1" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head runat="server"&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;title&gt;微信支付&lt;/title&gt;&lt;/head&gt;&lt;body style="background-color: #efeff4;"&gt; &lt;form runat="server" id="calculator" v-cloak&gt; &lt;div class="content-block"&gt; &lt;a id="test" href="&lt;%=test%&gt;" class="button"&gt;支付宝结算&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//绑定单击事件 var btn = document.querySelector("#test"); btn.addEventListener("click", function (e) &#123; e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); //ele.href 是GET到支付宝收银台的URL _AP.pay(e.target.href); return false; &#125;, false);&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using CYQ.Data;using Web.Lianmengban_2016;using CYQ.Data.Table;using Aop.Api.Util;using Aop.Api;using Aop.Api.Request;using Aop.Api.Response;public partial class JsApiPayPage1 : System.Web.UI.Page&#123; public static string test &#123; get; set; &#125; protected void Page_Load(object sender, EventArgs e) &#123; CreateAliPayPramaters(); &#125; private void CreateAliPayPramaters() &#123; //pageExecute&lt;T&gt;(IAopRequest&lt;T&gt; request, string accessToken, string reqMethod) where T : AopResponse IAopClient client = new DefaultAopClient("https://openapi.alipay.com/gateway.do", AliConfig.APP_ID, AliConfig.APP_PRIVATE_KEY, "json", "1.0", "RSA2", AliConfig.ALIPAY_PUBLIC_KEY, AliConfig.CHARSET, false); //实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称如：alipay.open.public.template.message.industry.modify AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); //AlipayOpenPublicTemplateMessageIndustryModifyRequest request = new AlipayOpenPublicTemplateMessageIndustryModifyRequest(); //SDK已经封装掉了公共参数，这里只需要传入业务参数 //此次只是参数展示，未进行字符串转义，实际情况下请转义 request.BizContent = "&#123;" + " \"subject\":\"大乐透\"," + " \"out_trade_no\":\"70501111111S0011111191\"," + " \"total_amount\":0.01," + " \"product_code\":\"QUICK_WAP_WAY\"" + " &#125;"; AlipayTradeWapPayResponse response = client.pageExecute(request,null,"GET"); test = response.Body; &#125; &#125; 12345678910111213141516public class AliConfig&#123; //=======【基本信息设置】===================================== /* 支付宝手机网页支付信息配置 public const string URL = "https://openapi.alipay.com/gateway.do"; public const string APP_ID = "20170111111144"; public const string APP_PRIVATE_KEY = @"MIIEowIBAAKCAQEA31kawX3d***t"; public const string FORMAT = "json"; public const string CHARSET = "utf-8"; public const string ALIPAY_PUBLIC_KEY = @"MIIBIjANBgkqhkiG9***"; public const string SIGN_TYPE = "RSA2"; public const string SELLER_EMAIL = "1234@123.com"; public const string NOTIFY_URL = "http://www.222.net/ResultNotifyAliPay.aspx"; public const string RETURN_URL = "http://www.222.net/AliReturnPage.aspx";&#125; 总结及出现的问题1、参数的内容按照api提供的列表把必填项的key及value一定要写全，写对；2、BizContent的业务参数内多个参数之间用“，”号隔开，之前忘记写全，报错；3、签名错误sign_valid API里面生成签名，包括sign_type接收支付宝的异步通知时，验签之前不包括sign 和 sign_type 签名sign生成规则支付宝官方sdk有个bug，Aop.Api.Util.AlipaySignature类中方法没有去掉sign_type就进行验证，导致出错； 1234567891011121314151617181920212223242526272829303132 public static bool RSACheckV2(IDictionary&lt;string, string&gt; parameters, string publicKeyPem) &#123; string sign = parameters["sign"]; parameters.Remove("sign"); parameters.Remove("sign_type");//新增修改bug string signContent = GetSignContent(parameters); return RSACheckContent(signContent, sign, publicKeyPem, DEFAULT_CHARSET, "RSA"); &#125; public static bool RSACheckV2(IDictionary&lt;string, string&gt; parameters, string publicKeyPem, string charset) &#123; string sign = parameters["sign"]; parameters.Remove("sign"); parameters.Remove("sign_type");//新增修改bug string signContent = GetSignContent(parameters); return RSACheckContent(signContent, sign, publicKeyPem, charset, "RSA"); &#125;public static bool RSACheckV2(IDictionary&lt;string, string&gt; parameters, string publicKeyPem, string charset, string signType, bool keyFromFile) &#123; string sign = parameters["sign"]; parameters.Remove("sign"); parameters.Remove("sign_type");//新增修改bug string signContent = GetSignContent(parameters); return RSACheckContent(signContent, sign, publicKeyPem, charset, signType, keyFromFile); &#125; 4、交易订单处理失败 请稍后再试 ali38173转到支付宝时，弹出这个错误，找了很久，才发现是由于Bizcontent的最后一个}括号内包含一个全角的空格，很坑啊；]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.net动态控制发布IIS网站（一）]]></title>
    <url>%2F2017%2F06%2F20%2Fnet%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6%E5%8F%91%E5%B8%83IIS%E7%BD%91%E7%AB%99%E4%B8%80%2F</url>
    <content type="text"><![CDATA[资料1.Microsoft.Web.Administration IIS操作API 代码简介主要逻辑功能 拷贝网站发布文件夹-&gt;IIS创建站点(获得空闲端口)-&gt;绑定域名 涉及到两个工具类1、IISManager IIS管理类2、DirFileHelper 文件及文件夹操作类 代码详情12345678910111213141516171819202122232425262728293031323334353637383940using CommonTools;using System;using System.Collections;namespace IIS&#123; class Program &#123; static void Main(string[] args) &#123; string folderName = "D:\\WebSiteTest";//发布网站目录 string physicsPath = "D:\\WebSite0421";//模板网站目录 ArrayList ports = IISManager.GetAllUsePorts(); for (int i = 0; i &lt; 30; i++) &#123; string port = IISManager.GetFreePort(ref ports); //Console.WriteLine(port); string currentWebsiteName = "WebSite" + i; string currentPath = folderName + "\\" + currentWebsiteName; DirFileHelper.CopyFolder(physicsPath, currentPath); IISManager.CreateWebSite(currentWebsiteName, currentPath, port); IISManager.BindHost(currentWebsiteName, "www.baidu.com" + i); System.Console.WriteLine("网站名：" + currentWebsiteName + "端口号：" + port + "路径：" + currentPath + " 域名:" + "www.baidu.com" + i); &#125; //for (int i = 0; i &lt; 30; i++) //&#123; // IISManager.DeleteWebSite("WebSite" + i); //&#125; Console.ReadKey(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325using Microsoft.Web.Administration;using System;using System.Collections;using System.Diagnostics;using System.IO;using System.Text.RegularExpressions;namespace CommonTools&#123; public static class IISManager &#123; private static ServerManager serverManager = new ServerManager(); /// &lt;summary&gt; /// 创建站点 /// &lt;/summary&gt; /// &lt;param name="websiteName"&gt;站点名&lt;/param&gt; /// &lt;param name="physicsPath"&gt;物理路径&lt;/param&gt; /// &lt;param name="ip"&gt;ip地址&lt;/param&gt; /// &lt;param name="port"&gt;端口号&lt;/param&gt; /// &lt;param name="poolver"&gt;应用程序池的DOTNET FRAMEWORK版本&lt;/param&gt; /// &lt;param name="binding"&gt;使用的协议&lt;/param&gt; public static void CreateWebSite(string websiteName, string physicsPath, string port, string ip = "*", string poolver = "v4.0", string binding = "http") &#123; try &#123; string fullIP = ip + ":" + port + ":"; ApplicationPool newPool = serverManager.ApplicationPools.Add(websiteName); newPool.ManagedRuntimeVersion = poolver; Site mySide = serverManager.Sites.Add(websiteName, binding, fullIP, physicsPath); mySide.Applications[0].ApplicationPoolName = websiteName; serverManager.CommitChanges(); &#125; catch (Exception error) &#123; &#125; &#125; /// &lt;summary&gt; /// 删除站点 /// &lt;/summary&gt; /// &lt;param name="websiteName"&gt;站点名称&lt;/param&gt; public static void DeleteWebSite(string websiteName) &#123; serverManager.Sites.Remove(serverManager.Sites[websiteName]); serverManager.ApplicationPools.Remove(serverManager.ApplicationPools[websiteName]); serverManager.CommitChanges(); &#125; /// &lt;summary&gt; /// 获得空闲端口 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static ArrayList GetAllUsePorts() &#123; Process p = new Process(); p.StartInfo.FileName = "cmd.exe";//设置启动的应用程序 p.StartInfo.UseShellExecute = false;//禁止使用操作系统外壳程序启动进程 p.StartInfo.RedirectStandardInput = true;//应用程序的输入从流中读取 p.StartInfo.RedirectStandardOutput = true;//应用程序的输出写入流中 p.StartInfo.RedirectStandardError = true;//将错误信息写入流 p.StartInfo.CreateNoWindow = true;//是否在新窗口中启动进程 p.Start(); //p.StandardInput.WriteLine(@"netstat -a -n&gt;c:\port.txt");//将字符串写入文本流 p.StandardInput.WriteLine(@"netstat -a -n"); p.StandardInput.WriteLine("exit"); string str; StreamReader reader = p.StandardOutput; str = reader.ReadLine(); ArrayList ports = new ArrayList(); ////匹配出端口号 string pattern = @":\d+"; //正则表达式字符串 Regex regex = new Regex(pattern); while (!reader.EndOfStream) &#123; Match match = regex.Match(str); if (match.Success) &#123; string port = match.Groups[0].Value.Substring(1); ports.Add(int.Parse(port)); &#125; str = reader.ReadLine(); &#125; return ports; &#125; /// &lt;summary&gt; /// 追加绑定域名 /// &lt;/summary&gt; /// &lt;param name="websiteName"&gt;站点名&lt;/param&gt; /// &lt;param name="hostName"&gt;域名&lt;/param&gt; public static void BindHost(string websiteName, string hostName) &#123; BindingCollection bindings = serverManager.Sites[websiteName].Bindings; for (int i = 1; i &lt; bindings.Count; i++) &#123; serverManager.Sites[websiteName].Bindings.RemoveAt(i); &#125; serverManager.Sites[websiteName].Bindings.Add("*:80:" + hostName, "http"); serverManager.CommitChanges(); &#125; /// &lt;summary&gt; /// 获得当前IIS网站运行列表 /// &lt;/summary&gt; public static void GetListOfIIS() &#123; string StateStr = ""; for (int i = 0; i &lt; serverManager.Sites.Count; i++) &#123; switch (serverManager.Sites[i].State) &#123; case ObjectState.Started: &#123; StateStr = "正常"; break; &#125; case ObjectState.Starting: &#123; StateStr = "正在启动"; break; &#125; case ObjectState.Stopping: &#123; StateStr = "正在关闭"; break; &#125; case ObjectState.Stopped: &#123; StateStr = "关闭"; break; &#125; &#125; Console.WriteLine(serverManager.Sites[i].Name + "【" + StateStr + "】"); &#125; &#125; /// &lt;summary&gt; /// 获得当前IIS站点状态 /// &lt;/summary&gt; public static void ReadConfig() &#123; System.Console.WriteLine("应用程序池默认设置："); System.Console.WriteLine("\t常规："); System.Console.WriteLine("\t\t.NET Framework 版本：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ManagedRuntimeVersion); System.Console.WriteLine("\t\t队列长度：&#123;0&#125;", serverManager.ApplicationPoolDefaults.QueueLength); System.Console.WriteLine("\t\t托管管道模式：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ManagedPipelineMode.ToString()); System.Console.WriteLine("\t\t自动启动：&#123;0&#125;", serverManager.ApplicationPoolDefaults.AutoStart); System.Console.WriteLine("\tCPU："); System.Console.WriteLine("\t\t处理器关联掩码：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.SmpProcessorAffinityMask); System.Console.WriteLine("\t\t限制：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.Limit); System.Console.WriteLine("\t\t限制操作：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.Action.ToString()); System.Console.WriteLine("\t\t限制间隔（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.ResetInterval.TotalMinutes); System.Console.WriteLine("\t\t已启用处理器关联：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Cpu.SmpAffinitized); System.Console.WriteLine("\t回收："); System.Console.WriteLine("\t\t发生配置更改时禁止回收：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.DisallowRotationOnConfigChange); System.Console.WriteLine("\t\t固定时间间隔（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Time.TotalMinutes); System.Console.WriteLine("\t\t禁用重叠回收：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.DisallowOverlappingRotation); System.Console.WriteLine("\t\t请求限制：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Requests); System.Console.WriteLine("\t\t虚拟内存限制（KB）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Memory); System.Console.WriteLine("\t\t专用内存限制（KB）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.PrivateMemory); System.Console.WriteLine("\t\t特定时间：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.PeriodicRestart.Schedule.ToString()); System.Console.WriteLine("\t\t生成回收事件日志条目：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Recycling.LogEventOnRecycle.ToString()); System.Console.WriteLine("\t进程孤立："); System.Console.WriteLine("\t\t可执行文件：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.OrphanActionExe); System.Console.WriteLine("\t\t可执行文件参数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.OrphanActionParams); System.Console.WriteLine("\t\t已启用：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.OrphanWorkerProcess); System.Console.WriteLine("\t进程模型："); System.Console.WriteLine("\t\tPing 间隔（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.PingInterval.TotalSeconds); System.Console.WriteLine("\t\tPing 最大响应时间（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.PingResponseTime.TotalSeconds); System.Console.WriteLine("\t\t标识：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.IdentityType); System.Console.WriteLine("\t\t用户名：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.UserName); System.Console.WriteLine("\t\t密码：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.Password); System.Console.WriteLine("\t\t关闭时间限制（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.ShutdownTimeLimit.TotalSeconds); System.Console.WriteLine("\t\t加载用户配置文件：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.LoadUserProfile); System.Console.WriteLine("\t\t启动时间限制（秒）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.StartupTimeLimit.TotalSeconds); System.Console.WriteLine("\t\t允许 Ping：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.PingingEnabled); System.Console.WriteLine("\t\t闲置超时（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.IdleTimeout.TotalMinutes); System.Console.WriteLine("\t\t最大工作进程数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.ProcessModel.MaxProcesses); System.Console.WriteLine("\t快速故障防护："); System.Console.WriteLine("\t\t“服务不可用”响应类型：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.LoadBalancerCapabilities.ToString()); System.Console.WriteLine("\t\t故障间隔（分钟）：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.RapidFailProtectionInterval.TotalMinutes); System.Console.WriteLine("\t\t关闭可执行文件：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.AutoShutdownExe); System.Console.WriteLine("\t\t关闭可执行文件参数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.AutoShutdownParams); System.Console.WriteLine("\t\t已启用：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.RapidFailProtection); System.Console.WriteLine("\t\t最大故障数：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Failure.RapidFailProtectionMaxCrashes); System.Console.WriteLine("\t\t允许32位应用程序运行在64位 Windows 上：&#123;0&#125;", serverManager.ApplicationPoolDefaults.Enable32BitAppOnWin64); System.Console.WriteLine(); System.Console.WriteLine("网站默认设置："); System.Console.WriteLine("\t常规："); System.Console.WriteLine("\t\t物理路径凭据：UserName=&#123;0&#125;, Password=&#123;1&#125;", serverManager.VirtualDirectoryDefaults.UserName, serverManager.VirtualDirectoryDefaults.Password); System.Console.WriteLine("\t\t物理路径凭据登录类型：&#123;0&#125;", serverManager.VirtualDirectoryDefaults.LogonMethod.ToString()); System.Console.WriteLine("\t\t应用程序池：&#123;0&#125;", serverManager.ApplicationDefaults.ApplicationPoolName); System.Console.WriteLine("\t\t自动启动：&#123;0&#125;", serverManager.SiteDefaults.ServerAutoStart); System.Console.WriteLine("\t行为："); System.Console.WriteLine("\t\t连接限制："); System.Console.WriteLine("\t\t\t连接超时（秒）：&#123;0&#125;", serverManager.SiteDefaults.Limits.ConnectionTimeout.TotalSeconds); System.Console.WriteLine("\t\t\t最大并发连接数：&#123;0&#125;", serverManager.SiteDefaults.Limits.MaxConnections); System.Console.WriteLine("\t\t\t最大带宽（字节/秒）：&#123;0&#125;", serverManager.SiteDefaults.Limits.MaxBandwidth); System.Console.WriteLine("\t\t失败请求跟踪："); System.Console.WriteLine("\t\t\t跟踪文件的最大数量：&#123;0&#125;", serverManager.SiteDefaults.TraceFailedRequestsLogging.MaxLogFiles); System.Console.WriteLine("\t\t\t目录：&#123;0&#125;", serverManager.SiteDefaults.TraceFailedRequestsLogging.Directory); System.Console.WriteLine("\t\t\t已启用：&#123;0&#125;", serverManager.SiteDefaults.TraceFailedRequestsLogging.Enabled); System.Console.WriteLine("\t\t已启用的协议：&#123;0&#125;", serverManager.ApplicationDefaults.EnabledProtocols); foreach (var s in serverManager.Sites)//遍历网站 &#123; System.Console.WriteLine(); System.Console.WriteLine("模式名：&#123;0&#125;", s.Schema.Name); System.Console.WriteLine("编号：&#123;0&#125;", s.Id); System.Console.WriteLine("网站名称：&#123;0&#125;", s.Name); System.Console.WriteLine("物理路径：&#123;0&#125;", s.Applications["/"].VirtualDirectories["/"].PhysicalPath); System.Console.WriteLine("物理路径凭据：&#123;0&#125;", s.Methods.ToString()); System.Console.WriteLine("应用程序池：&#123;0&#125;", s.Applications["/"].ApplicationPoolName); System.Console.WriteLine("已启用的协议：&#123;0&#125;", s.Applications["/"].EnabledProtocols); System.Console.WriteLine("自动启动：&#123;0&#125;", s.ServerAutoStart); System.Console.WriteLine("运行状态：&#123;0&#125;", s.State.ToString()); System.Console.WriteLine("网站绑定："); foreach (var tmp in s.Bindings) &#123; System.Console.WriteLine("\t类型：&#123;0&#125;", tmp.Protocol); //System.Console.WriteLine("\tIP 地址：&#123;0&#125;", tmp.EndPoint.Address.ToString()); //System.Console.WriteLine("\t端口：&#123;0&#125;", tmp.EndPoint.Port.ToString()); System.Console.WriteLine("\t主机名：&#123;0&#125;", tmp.Host); //System.Console.WriteLine(tmp.BindingInformation); //System.Console.WriteLine(tmp.CertificateStoreName); //System.Console.WriteLine(tmp.IsIPPortHostBinding); //System.Console.WriteLine(tmp.IsLocallyStored); //System.Console.WriteLine(tmp.UseDsMapper); &#125; System.Console.WriteLine("连接限制："); System.Console.WriteLine("\t连接超时（秒）：&#123;0&#125;", s.Limits.ConnectionTimeout.TotalSeconds); System.Console.WriteLine("\t最大并发连接数：&#123;0&#125;", s.Limits.MaxConnections); System.Console.WriteLine("\t最大带宽（字节/秒）：&#123;0&#125;", s.Limits.MaxBandwidth); System.Console.WriteLine("失败请求跟踪："); System.Console.WriteLine("\t跟踪文件的最大数量：&#123;0&#125;", s.TraceFailedRequestsLogging.MaxLogFiles); System.Console.WriteLine("\t目录：&#123;0&#125;", s.TraceFailedRequestsLogging.Directory); System.Console.WriteLine("\t已启用：&#123;0&#125;", s.TraceFailedRequestsLogging.Enabled); System.Console.WriteLine("日志："); //System.Console.WriteLine("\t启用日志服务：&#123;0&#125;", s.LogFile.Enabled); System.Console.WriteLine("\t格式：&#123;0&#125;", s.LogFile.LogFormat.ToString()); System.Console.WriteLine("\t目录：&#123;0&#125;", s.LogFile.Directory); System.Console.WriteLine("\t文件包含字段：&#123;0&#125;", s.LogFile.LogExtFileFlags.ToString()); System.Console.WriteLine("\t计划：&#123;0&#125;", s.LogFile.Period.ToString()); System.Console.WriteLine("\t最大文件大小（字节）：&#123;0&#125;", s.LogFile.TruncateSize); System.Console.WriteLine("\t使用本地时间进行文件命名和滚动更新：&#123;0&#125;", s.LogFile.LocalTimeRollover); System.Console.WriteLine("----应用程序的默认应用程序池：&#123;0&#125;", s.ApplicationDefaults.ApplicationPoolName); System.Console.WriteLine("----应用程序的默认已启用的协议：&#123;0&#125;", s.ApplicationDefaults.EnabledProtocols); //System.Console.WriteLine("----应用程序的默认物理路径凭据：&#123;0&#125;", s.ApplicationDefaults.Methods.ToString()); //System.Console.WriteLine("----虚拟目录的默认物理路径凭据：&#123;0&#125;", s.VirtualDirectoryDefaults.Methods.ToString()); System.Console.WriteLine("----虚拟目录的默认物理路径凭据登录类型：&#123;0&#125;", s.VirtualDirectoryDefaults.LogonMethod.ToString()); System.Console.WriteLine("----虚拟目录的默认用户名：&#123;0&#125;", s.VirtualDirectoryDefaults.UserName); System.Console.WriteLine("----虚拟目录的默认用户密码：&#123;0&#125;", s.VirtualDirectoryDefaults.Password); System.Console.WriteLine("应用程序 列表："); foreach (var tmp in s.Applications) &#123; if (tmp.Path != "/") &#123; System.Console.WriteLine("\t模式名：&#123;0&#125;", tmp.Schema.Name); System.Console.WriteLine("\t虚拟路径：&#123;0&#125;", tmp.Path); System.Console.WriteLine("\t物理路径：&#123;0&#125;", tmp.VirtualDirectories["/"].PhysicalPath); //System.Console.WriteLine("\t物理路径凭据：&#123;0&#125;", tmp.Methods.ToString()); System.Console.WriteLine("\t应用程序池：&#123;0&#125;", tmp.ApplicationPoolName); System.Console.WriteLine("\t已启用的协议：&#123;0&#125;", tmp.EnabledProtocols); &#125; System.Console.WriteLine("\t虚拟目录 列表："); foreach (var tmp2 in tmp.VirtualDirectories) &#123; if (tmp2.Path != "/") &#123; System.Console.WriteLine("\t\t模式名：&#123;0&#125;", tmp2.Schema.Name); System.Console.WriteLine("\t\t虚拟路径：&#123;0&#125;", tmp2.Path); System.Console.WriteLine("\t\t物理路径：&#123;0&#125;", tmp2.PhysicalPath); //System.Console.WriteLine("\t\t物理路径凭据：&#123;0&#125;", tmp2.Methods.ToString()); System.Console.WriteLine("\t\t物理路径凭据登录类型：&#123;0&#125;", tmp2.LogonMethod.ToString()); &#125; &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 获得可用端口号 /// &lt;/summary&gt; /// &lt;param name="ports"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetFreePort(ref ArrayList ports) &#123; ////1024－49151 string result = ""; for (int i = 1024; i &lt; 49151; i++) &#123; if (!ports.Contains(i)) &#123; ports.Add(i); result = i.ToString(); break; &#125; &#125; return result; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763using System;using System.Text;using System.IO;namespace CommonTools&#123; /// &lt;summary&gt; /// 文件操作夹 /// &lt;/summary&gt; public static class DirFileHelper &#123; #region 检测指定目录是否存在 /// &lt;summary&gt; /// 检测指定目录是否存在 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;目录的绝对路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsExistDirectory(string directoryPath) &#123; return Directory.Exists(directoryPath); &#125; #endregion #region 检测指定文件是否存在,如果存在返回true /// &lt;summary&gt; /// 检测指定文件是否存在,如果存在则返回true。 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static bool IsExistFile(string filePath) &#123; return File.Exists(filePath); &#125; #endregion #region 获取指定目录中的文件列表 /// &lt;summary&gt; /// 获取指定目录中所有文件列表 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static string[] GetFileNames(string directoryPath) &#123; //如果目录不存在，则抛出异常 if (!IsExistDirectory(directoryPath)) &#123; throw new FileNotFoundException(); &#125; //获取文件列表 return Directory.GetFiles(directoryPath); &#125; #endregion #region 获取指定目录中所有子目录列表,若要搜索嵌套的子目录列表,请使用重载方法. /// &lt;summary&gt; /// 获取指定目录中所有子目录列表,若要搜索嵌套的子目录列表,请使用重载方法. /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static string[] GetDirectories(string directoryPath) &#123; try &#123; return Directory.GetDirectories(directoryPath); &#125; catch (IOException ex) &#123; throw ex; &#125; &#125; #endregion #region 获取指定目录及子目录中所有文件列表 /// &lt;summary&gt; /// 获取指定目录及子目录中所有文件列表 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; /// &lt;param name="isSearchChild"&gt;是否搜索子目录&lt;/param&gt; public static string[] GetFileNames(string directoryPath, string searchPattern, bool isSearchChild) &#123; //如果目录不存在，则抛出异常 if (!IsExistDirectory(directoryPath)) &#123; throw new FileNotFoundException(); &#125; try &#123; if (isSearchChild) &#123; return Directory.GetFiles(directoryPath, searchPattern, SearchOption.AllDirectories); &#125; else &#123; return Directory.GetFiles(directoryPath, searchPattern, SearchOption.TopDirectoryOnly); &#125; &#125; catch (IOException ex) &#123; throw ex; &#125; &#125; #endregion #region 检测指定目录是否为空 /// &lt;summary&gt; /// 检测指定目录是否为空 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static bool IsEmptyDirectory(string directoryPath) &#123; try &#123; //判断是否存在文件 string[] fileNames = GetFileNames(directoryPath); if (fileNames.Length &gt; 0) &#123; return false; &#125; //判断是否存在文件夹 string[] directoryNames = GetDirectories(directoryPath); if (directoryNames.Length &gt; 0) &#123; return false; &#125; return true; &#125; catch &#123; //这里记录日志 //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); return true; &#125; &#125; #endregion #region 检测指定目录中是否存在指定的文件 /// &lt;summary&gt; /// 检测指定目录中是否存在指定的文件,若要搜索子目录请使用重载方法. /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; public static bool Contains(string directoryPath, string searchPattern) &#123; try &#123; //获取指定的文件列表 string[] fileNames = GetFileNames(directoryPath, searchPattern, false); //判断指定文件是否存在 if (fileNames.Length == 0) &#123; return false; &#125; else &#123; return true; &#125; &#125; catch (Exception ex) &#123; throw new Exception(ex.Message); //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); &#125; &#125; /// &lt;summary&gt; /// 检测指定目录中是否存在指定的文件 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; /// &lt;param name="isSearchChild"&gt;是否搜索子目录&lt;/param&gt; public static bool Contains(string directoryPath, string searchPattern, bool isSearchChild) &#123; try &#123; //获取指定的文件列表 string[] fileNames = GetFileNames(directoryPath, searchPattern, true); //判断指定文件是否存在 if (fileNames.Length == 0) &#123; return false; &#125; else &#123; return true; &#125; &#125; catch (Exception ex) &#123; throw new Exception(ex.Message); //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); &#125; &#125; #endregion #region 创建目录 /// &lt;summary&gt; /// 创建目录 /// &lt;/summary&gt; /// &lt;param name="dir"&gt;要创建的目录路径包括目录名&lt;/param&gt; public static void CreateDir(string dir) &#123; if (dir.Length == 0) return; if (!Directory.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir)) Directory.CreateDirectory(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir); &#125; #endregion #region 删除目录 /// &lt;summary&gt; /// 删除目录 /// &lt;/summary&gt; /// &lt;param name="dir"&gt;要删除的目录路径和名称&lt;/param&gt; public static void DeleteDir(string dir) &#123; if (dir.Length == 0) return; if (Directory.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir)) Directory.Delete(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir); &#125; #endregion #region 删除文件 /// &lt;summary&gt; /// 删除文件 /// &lt;/summary&gt; /// &lt;param name="file"&gt;要删除的文件路径和名称&lt;/param&gt; public static void DeleteFile(string file) &#123; if (File.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + file)) File.Delete(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + file); &#125; #endregion #region 创建文件 /// &lt;summary&gt; /// 创建文件 /// &lt;/summary&gt; /// &lt;param name="dir"&gt;带后缀的文件名&lt;/param&gt; /// &lt;param name="pagestr"&gt;文件内容&lt;/param&gt; public static void CreateFile(string dir, string pagestr) &#123; dir = dir.Replace("/", "\\"); if (dir.IndexOf("\\") &gt; -1) CreateDir(dir.Substring(0, dir.LastIndexOf("\\"))); System.IO.StreamWriter sw = new System.IO.StreamWriter(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir, false, System.Text.Encoding.GetEncoding("GB2312")); sw.Write(pagestr); sw.Close(); &#125; #endregion #region 移动文件(剪贴--粘贴) /// &lt;summary&gt; /// 移动文件(剪贴--粘贴) /// &lt;/summary&gt; /// &lt;param name="dir1"&gt;要移动的文件的路径及全名(包括后缀)&lt;/param&gt; /// &lt;param name="dir2"&gt;文件移动到新的位置,并指定新的文件名&lt;/param&gt; public static void MoveFile(string dir1, string dir2) &#123; dir1 = dir1.Replace("/", "\\"); dir2 = dir2.Replace("/", "\\"); if (File.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1)) File.Move(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1, System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir2); &#125; #endregion #region 复制文件 /// &lt;summary&gt; /// 复制文件 /// &lt;/summary&gt; /// &lt;param name="dir1"&gt;要复制的文件的路径已经全名(包括后缀)&lt;/param&gt; /// &lt;param name="dir2"&gt;目标位置,并指定新的文件名&lt;/param&gt; public static void CopyFile(string dir1, string dir2) &#123; dir1 = dir1.Replace("/", "\\"); dir2 = dir2.Replace("/", "\\"); if (File.Exists(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1)) &#123; File.Copy(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1, System.Web.HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir2, true); &#125; &#125; #endregion #region 根据时间得到目录名 / 格式:yyyyMMdd 或者 HHmmssff /// &lt;summary&gt; /// 根据时间得到目录名yyyyMMdd /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetDateDir() &#123; return DateTime.Now.ToString("yyyyMMdd"); &#125; /// &lt;summary&gt; /// 根据时间得到文件名HHmmssff /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetDateFile() &#123; return DateTime.Now.ToString("HHmmssff"); &#125; #endregion #region 复制文件夹 /// &lt;summary&gt; /// 复制文件夹(递归) /// &lt;/summary&gt; /// &lt;param name="varFromDirectory"&gt;源文件夹路径&lt;/param&gt; /// &lt;param name="varToDirectory"&gt;目标文件夹路径&lt;/param&gt; public static void CopyFolder(string varFromDirectory, string varToDirectory) &#123; Directory.CreateDirectory(varToDirectory); if (!Directory.Exists(varFromDirectory)) return; string[] directories = Directory.GetDirectories(varFromDirectory); if (directories.Length &gt; 0) &#123; foreach (string d in directories) &#123; CopyFolder(d, varToDirectory + d.Substring(d.LastIndexOf("\\"))); &#125; &#125; string[] files = Directory.GetFiles(varFromDirectory); if (files.Length &gt; 0) &#123; foreach (string s in files) &#123; File.Copy(s, varToDirectory + s.Substring(s.LastIndexOf("\\")), true); &#125; &#125; &#125; #endregion #region 检查文件,如果文件不存在则创建 /// &lt;summary&gt; /// 检查文件,如果文件不存在则创建 /// &lt;/summary&gt; /// &lt;param name="FilePath"&gt;路径,包括文件名&lt;/param&gt; public static void ExistsFile(string FilePath) &#123; //if(!File.Exists(FilePath)) //File.Create(FilePath); //以上写法会报错,详细解释请看下文......... if (!File.Exists(FilePath)) &#123; FileStream fs = File.Create(FilePath); fs.Close(); &#125; &#125; #endregion #region 删除指定文件夹对应其他文件夹里的文件 /// &lt;summary&gt; /// 删除指定文件夹对应其他文件夹里的文件 /// &lt;/summary&gt; /// &lt;param name="varFromDirectory"&gt;指定文件夹路径&lt;/param&gt; /// &lt;param name="varToDirectory"&gt;对应其他文件夹路径&lt;/param&gt; public static void DeleteFolderFiles(string varFromDirectory, string varToDirectory) &#123; Directory.CreateDirectory(varToDirectory); if (!Directory.Exists(varFromDirectory)) return; string[] directories = Directory.GetDirectories(varFromDirectory); if (directories.Length &gt; 0) &#123; foreach (string d in directories) &#123; DeleteFolderFiles(d, varToDirectory + d.Substring(d.LastIndexOf("\\"))); &#125; &#125; string[] files = Directory.GetFiles(varFromDirectory); if (files.Length &gt; 0) &#123; foreach (string s in files) &#123; File.Delete(varToDirectory + s.Substring(s.LastIndexOf("\\"))); &#125; &#125; &#125; #endregion #region 从文件的绝对路径中获取文件名( 包含扩展名 ) /// &lt;summary&gt; /// 从文件的绝对路径中获取文件名( 包含扩展名 ) /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static string GetFileName(string filePath) &#123; //获取文件的名称 FileInfo fi = new FileInfo(filePath); return fi.Name; &#125; #endregion /// &lt;summary&gt; /// 复制文件参考方法,页面中引用 /// &lt;/summary&gt; /// &lt;param name="cDir"&gt;新路径&lt;/param&gt; /// &lt;param name="TempId"&gt;模板引擎替换编号&lt;/param&gt; public static void CopyFiles(string cDir, string TempId) &#123; //if (Directory.Exists(Request.PhysicalApplicationPath + "\\Controls")) //&#123; // string TempStr = string.Empty; // StreamWriter sw; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Default.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Default.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Default.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Column.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Column.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\List.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Content.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Content.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\View.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\MoreDiss.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\MoreDiss.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\DissList.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\ShowDiss.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\ShowDiss.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Diss.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Review.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Review.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Review.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; // if (File.Exists(Request.PhysicalApplicationPath + "\\Controls\\Search.aspx")) // &#123; // TempStr = File.ReadAllText(Request.PhysicalApplicationPath + "\\Controls\\Search.aspx"); // TempStr = TempStr.Replace("&#123;$ChannelId$&#125;", TempId); // sw = new StreamWriter(Request.PhysicalApplicationPath + "\\" + cDir + "\\Search.aspx", false, System.Text.Encoding.GetEncoding("GB2312")); // sw.Write(TempStr); // sw.Close(); // &#125; //&#125; &#125; #region 创建一个目录 /// &lt;summary&gt; /// 创建一个目录 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;目录的绝对路径&lt;/param&gt; public static void CreateDirectory(string directoryPath) &#123; //如果目录不存在则创建该目录 if (!IsExistDirectory(directoryPath)) &#123; Directory.CreateDirectory(directoryPath); &#125; &#125; #endregion #region 创建一个文件 /// &lt;summary&gt; /// 创建一个文件。 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static void CreateFile(string filePath) &#123; try &#123; //如果文件不存在则创建该文件 if (!IsExistFile(filePath)) &#123; //创建一个FileInfo对象 FileInfo file = new FileInfo(filePath); //创建文件 FileStream fs = file.Create(); //关闭文件流 fs.Close(); &#125; &#125; catch (Exception ex) &#123; //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); throw ex; &#125; &#125; /// &lt;summary&gt; /// 创建一个文件,并将字节流写入文件。 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; /// &lt;param name="buffer"&gt;二进制流数据&lt;/param&gt; public static void CreateFile(string filePath, byte[] buffer) &#123; try &#123; //如果文件不存在则创建该文件 if (!IsExistFile(filePath)) &#123; //创建一个FileInfo对象 FileInfo file = new FileInfo(filePath); //创建文件 FileStream fs = file.Create(); //写入二进制流 fs.Write(buffer, 0, buffer.Length); //关闭文件流 fs.Close(); &#125; &#125; catch (Exception ex) &#123; //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message); throw ex; &#125; &#125; #endregion #region 获取文本文件的行数 /// &lt;summary&gt; /// 获取文本文件的行数 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static int GetLineCount(string filePath) &#123; //将文本文件的各行读到一个字符串数组中 string[] rows = File.ReadAllLines(filePath); //返回行数 return rows.Length; &#125; #endregion #region 获取一个文件的长度 /// &lt;summary&gt; /// 获取一个文件的长度,单位为Byte /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static int GetFileSize(string filePath) &#123; //创建一个文件对象 FileInfo fi = new FileInfo(filePath); //获取文件的大小 return (int)fi.Length; &#125; #endregion #region 获取指定目录中的子目录列表 /// &lt;summary&gt; /// 获取指定目录及子目录中所有子目录列表 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; /// &lt;param name="searchPattern"&gt;模式字符串，"*"代表0或N个字符，"?"代表1个字符。 /// 范例："Log*.xml"表示搜索所有以Log开头的Xml文件。&lt;/param&gt; /// &lt;param name="isSearchChild"&gt;是否搜索子目录&lt;/param&gt; public static string[] GetDirectories(string directoryPath, string searchPattern, bool isSearchChild) &#123; try &#123; if (isSearchChild) &#123; return Directory.GetDirectories(directoryPath, searchPattern, SearchOption.AllDirectories); &#125; else &#123; return Directory.GetDirectories(directoryPath, searchPattern, SearchOption.TopDirectoryOnly); &#125; &#125; catch (IOException ex) &#123; throw ex; &#125; &#125; #endregion #region 向文本文件写入内容 /// &lt;summary&gt; /// 向文本文件中写入内容 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; /// &lt;param name="text"&gt;写入的内容&lt;/param&gt; /// &lt;param name="encoding"&gt;编码&lt;/param&gt; public static void WriteText(string filePath, string text, Encoding encoding) &#123; //向文件写入内容 File.WriteAllText(filePath, text, encoding); &#125; #endregion #region 向文本文件的尾部追加内容 /// &lt;summary&gt; /// 向文本文件的尾部追加内容 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; /// &lt;param name="content"&gt;写入的内容&lt;/param&gt; public static void AppendText(string filePath, string content) &#123; File.AppendAllText(filePath, content); &#125; #endregion #region 将现有文件的内容复制到新文件中 /// &lt;summary&gt; /// 将源文件的内容复制到目标文件中 /// &lt;/summary&gt; /// &lt;param name="sourceFilePath"&gt;源文件的绝对路径&lt;/param&gt; /// &lt;param name="destFilePath"&gt;目标文件的绝对路径&lt;/param&gt; public static void Copy(string sourceFilePath, string destFilePath) &#123; File.Copy(sourceFilePath, destFilePath, true); &#125; #endregion #region 将文件移动到指定目录 /// &lt;summary&gt; /// 将文件移动到指定目录 /// &lt;/summary&gt; /// &lt;param name="sourceFilePath"&gt;需要移动的源文件的绝对路径&lt;/param&gt; /// &lt;param name="descDirectoryPath"&gt;移动到的目录的绝对路径&lt;/param&gt; public static void Move(string sourceFilePath, string descDirectoryPath) &#123; //获取源文件的名称 string sourceFileName = GetFileName(sourceFilePath); if (IsExistDirectory(descDirectoryPath)) &#123; //如果目标中存在同名文件,则删除 if (IsExistFile(descDirectoryPath + "\\" + sourceFileName)) &#123; DeleteFile(descDirectoryPath + "\\" + sourceFileName); &#125; //将文件移动到指定目录 File.Move(sourceFilePath, descDirectoryPath + "\\" + sourceFileName); &#125; &#125; #endregion #region 从文件的绝对路径中获取文件名( 不包含扩展名 ) /// &lt;summary&gt; /// 从文件的绝对路径中获取文件名( 不包含扩展名 ) /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static string GetFileNameNoExtension(string filePath) &#123; //获取文件的名称 FileInfo fi = new FileInfo(filePath); return fi.Name.Split('.')[0]; &#125; #endregion #region 从文件的绝对路径中获取扩展名 /// &lt;summary&gt; /// 从文件的绝对路径中获取扩展名 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static string GetExtension(string filePath) &#123; //获取文件的名称 FileInfo fi = new FileInfo(filePath); return fi.Extension; &#125; #endregion #region 清空指定目录 /// &lt;summary&gt; /// 清空指定目录下所有文件及子目录,但该目录依然保存. /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static void ClearDirectory(string directoryPath) &#123; if (IsExistDirectory(directoryPath)) &#123; //删除目录中所有的文件 string[] fileNames = GetFileNames(directoryPath); for (int i = 0; i &lt; fileNames.Length; i++) &#123; DeleteFile(fileNames[i]); &#125; //删除目录中所有的子目录 string[] directoryNames = GetDirectories(directoryPath); for (int i = 0; i &lt; directoryNames.Length; i++) &#123; DeleteDirectory(directoryNames[i]); &#125; &#125; &#125; #endregion #region 清空文件内容 /// &lt;summary&gt; /// 清空文件内容 /// &lt;/summary&gt; /// &lt;param name="filePath"&gt;文件的绝对路径&lt;/param&gt; public static void ClearFile(string filePath) &#123; //删除文件 File.Delete(filePath); //重新创建该文件 CreateFile(filePath); &#125; #endregion #region 删除指定目录 /// &lt;summary&gt; /// 删除指定目录及其所有子目录 /// &lt;/summary&gt; /// &lt;param name="directoryPath"&gt;指定目录的绝对路径&lt;/param&gt; public static void DeleteDirectory(string directoryPath) &#123; if (IsExistDirectory(directoryPath)) &#123; Directory.Delete(directoryPath, true); &#125; &#125; #endregion &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.Net</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.net获得本机可用端口号]]></title>
    <url>%2F2017%2F06%2F19%2Fnet%E8%8E%B7%E5%BE%97%E6%9C%AC%E6%9C%BA%E5%8F%AF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[好久没有总结文字了，上周整理过一个IIS自动发布并绑定域名的demo，其中有一部分需要读取未使用的服务器端口号用来发布网站，因此整理出该方法。实现逻辑思路：.net 通过命令提示符窗口获得当前已用端口，再筛选出可用端口。 公用方法代码12345678910111213141516171819202122232425262728293031323334353637383940414243public string GetFreePort() &#123; string result = ""; Process p = new Process(); p.StartInfo.FileName = "cmd.exe";//设置启动的应用程序 p.StartInfo.UseShellExecute = false;//禁止使用操作系统外壳程序启动进程 p.StartInfo.RedirectStandardInput = true;//应用程序的输入从流中读取 p.StartInfo.RedirectStandardOutput = true;//应用程序的输出写入流中 p.StartInfo.RedirectStandardError = true;//将错误信息写入流 p.StartInfo.CreateNoWindow = true;//是否在新窗口中启动进程 p.Start(); //p.StandardInput.WriteLine(@"netstat -a -n&gt;c:\port.txt");//将字符串写入文本流 p.StandardInput.WriteLine(@"netstat -a -n"); p.StandardInput.WriteLine("exit"); //此处必须加退出命令，否则界面会卡死在cmd窗口无法继续执行 string str; StreamReader reader=p.StandardOutput; str = reader.ReadLine(); ArrayList ports = new ArrayList(); ////匹配出端口号 string pattern = @":\d+"; //正则表达式字符串 Regex regex = new Regex(pattern); while (!reader.EndOfStream) &#123; Match match = regex.Match(str); if (match.Success) &#123; string port = match.Groups[0].Value.Substring(1); ports.Add(port); &#125; Console.WriteLine(str); str = reader.ReadLine(); &#125; ////可用端口号范围1024－49151 for (int i = 1024; i &lt; 49151; i++) &#123; if (!ports.Contains(i)) &#123; result = i.ToString(); break; &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window服务守护外部程序不被关闭]]></title>
    <url>%2F2017%2F01%2F21%2Fwindow%E6%9C%8D%E5%8A%A1%E5%AE%88%E6%8A%A4%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、需求描述：保证程序能够一直运行，不会关闭。2、实现过程：创建windows服务并保持自动运行，该服务定时检查程序进程是否关闭，如果关闭则启动。3、实现过程中遇到的问题：windows服务直接打开外部程序，该程序只存在于任务管理器中的进程中，界面无法直接显示。 服务定时访问代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public partial class Service1 : ServiceBase &#123; private System.Timers.Timer aTimer;//定时器 public Service1() &#123; InitializeComponent(); &#125; protected override void OnStart(string[] args) &#123; // As creating a child process might be a time consuming operation, // its better to do that in a separate thread than blocking the main thread. //System.Threading.Thread ProcessCreationThread = new System.Threading.Thread(MyThreadFunc); //ProcessCreationThread.Start(); MyThreadFunc(); &#125; // This thread function would launch a child process // in the interactive session of the logged-on user. public void MyThreadFunc() &#123; Log.WriteLogToTxt("打开多屏系统"); aTimer = new System.Timers.Timer(); //第一次马上打开 timer1_Tick(null,null); //到达时间的时候执行事件； aTimer.Elapsed += new ElapsedEventHandler(timer1_Tick); // 设置引发时间的时间间隔 此处设置为1秒（1000毫秒） aTimer.Interval = Convert.ToDouble(AppConfig.GetApp("INTERVAL")); //设置是执行一次（false）还是一直执行(true)； aTimer.AutoReset = true; //是否执行System.Timers.Timer.Elapsed事件； aTimer.Enabled = true; aTimer.Start(); &#125; /// &lt;summary&gt; /// 定时事件 /// &lt;/summary&gt; /// &lt;param name="source"&gt;源对象&lt;/param&gt; /// &lt;param name="e"&gt;ElapsedEventArgs事件对象&lt;/param&gt; protected void timer1_Tick(object source, ElapsedEventArgs e) &#123; bool isProcessResult = IsProcessStarted("IocpServer");//判断是否运行 if (!isProcessResult) &#123; //Debugger.Launch();调试debug Log.WriteLogToTxt("自动开始运行"); //此处可以直接将exe运行地址赋值如c:\1.exe string applicationLocation = AppConfig.GetApp("ApplicationLocation"); Log.WriteLogToTxt(applicationLocation); CreateProcessAsUserWrapper.LaunchChildProcess(applicationLocation); &#125; &#125; private void myprocess_Exited(object sender, EventArgs e)//被触发的程序 &#123; Log.WriteLogToTxt("关闭多屏系统"); &#125; /// &lt;summary&gt; /// 判断程序是否运行 /// &lt;/summary&gt; /// &lt;param name="processName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private bool IsProcessStarted(string processName) &#123; Process[] temp = Process.GetProcessesByName(processName); if (temp.Length &gt; 0) &#123; string tempName = ""; foreach (Process process in temp) &#123; tempName += process.ProcessName + ";"; &#125; //Log.WriteLogToTxt("程序名称" + tempName); return true; &#125; else &#123; return false; &#125; &#125; protected override void OnStop() &#123; &#125; &#125; 微软demo]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>WinForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周日历实现]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%91%A8%E6%97%A5%E5%8E%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[要实现的功能：通过点击或拖动选择在日历中根据时间段列出的课程单元格。该Table可用的功能包括：1、按周来显示的日历；2、可拖动、点击选择表格；3、可用来设置日程、课程相关table原型；遇到的坑：1、js对象使用地址引用来传递，导致循环获得moment时间对象的值放到数组中后，全部相同且是最后一个，最后使用new moment()，重新再创建一个对象来解决。12345var today=new moment();var array=new Array();for(var i=0;i&lt;3;i++)&#123; array.push(new moment(today.add(1,"days")));//添加一天 解决地址传递 &#125; 源码及演示]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态调用webservice]]></title>
    <url>%2F2016%2F12%2F24%2F%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8webservice%2F</url>
    <content type="text"><![CDATA[关于webservice的调用方法 之前使用或了解的只是通过vs的操作界面直接引入web服务而调用的，现在才知道调用的方式也可以使用反射的机制来实现， 网上找到的代码本地测试可以使用，留存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Web.Services.Description;using System.CodeDom;using Microsoft.CSharp;using System.CodeDom.Compiler;using System.Net;using System.IO;namespace DirectInvoke&#123; class Program &#123; static void Main(string[] args) &#123; string serviceUrl = "http://www.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx"; object o = Webservice.InvokeWebService(serviceUrl, "getSupportProvince", new object[] &#123; &#125;); &#125; //反射获得方法及成员 public void PrintInstanceInfor(Type t) &#123; //获取所有方法 System.Reflection.MethodInfo[] methods = t.GetMethods(); //获取所有成员 System.Reflection.MemberInfo[] members = t.GetMembers(); //获取所有属性 System.Reflection.PropertyInfo[] properties = t.GetProperties(); &#125; &#125; public class Webservice &#123; /// &lt;summary&gt; /// 实例化WebServices /// &lt;/summary&gt; /// &lt;param name="url"&gt;WebServices地址&lt;/param&gt; /// &lt;param name="methodname"&gt;调用的方法&lt;/param&gt; /// &lt;param name="args"&gt;把webservices里需要的参数按顺序放到这个object[]里&lt;/param&gt; public static object InvokeWebService(string url, string methodname, object[] args) &#123; //这里的namespace是需引用的webservices的命名空间，我没有改过，也可以使用。也可以加一个参数从外面传进来。 string @namespace = "client"; try &#123; //获取WSDL WebClient wc = new WebClient(); Stream stream = wc.OpenRead(url + "?WSDL"); ServiceDescription sd = ServiceDescription.Read(stream); string classname = sd.Services[0].Name; ServiceDescriptionImporter sdi = new ServiceDescriptionImporter(); sdi.AddServiceDescription(sd, "", ""); CodeNamespace cn = new CodeNamespace(@namespace); //生成客户端代理类代码 CodeCompileUnit ccu = new CodeCompileUnit(); ccu.Namespaces.Add(cn); sdi.Import(cn, ccu); CSharpCodeProvider csc = new CSharpCodeProvider(); //ICodeCompiler icc = csc.CreateCompiler(); //设定编译参数 CompilerParameters cplist = new CompilerParameters(); cplist.GenerateExecutable = false; cplist.GenerateInMemory = true; cplist.ReferencedAssemblies.Add("System.dll"); cplist.ReferencedAssemblies.Add("System.xml.dll"); cplist.ReferencedAssemblies.Add("System.Web.Services.dll"); cplist.ReferencedAssemblies.Add("System.Data.dll"); //编译代理类 CompilerResults cr = csc.CompileAssemblyFromDom(cplist, ccu); if (true == cr.Errors.HasErrors) &#123; System.Text.StringBuilder sb = new System.Text.StringBuilder(); foreach (System.CodeDom.Compiler.CompilerError ce in cr.Errors) &#123; sb.Append(ce.ToString()); sb.Append(System.Environment.NewLine); &#125; throw new Exception(sb.ToString()); &#125; //生成代理实例，并调用方法 System.Reflection.Assembly assembly = cr.CompiledAssembly; Type t = assembly.GetType(@namespace + "." + classname, true, true); object obj = Activator.CreateInstance(t); System.Reflection.MethodInfo mi = t.GetMethod(methodname); return mi.Invoke(obj, args); &#125; catch &#123; return null; &#125; &#125; &#125;&#125; 核心代码转自]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>c#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS动态创建行]]></title>
    <url>%2F2016%2F12%2F02%2FJS%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[JS在前台动态创建表格行，行的数量按照用户来定，行内有select下拉框、文本框或者是easyui-combobox组合框。文本框增加数字验证。需要做如图的报表 1、js代码1234567891011121314151617181920212223242526//添加空行 function addRow() &#123; var rowNum = $(".firmRow").length; //增加第一行 var $newRow = $(".firmRow:first").clone(); $newRow.removeClass("hideFirmRow"); //修改名称// $newRow.find("select").attr("name", "cFirmGuid" + rowNum); //普通select下拉框 //easyui-combobox组合框控件 $newRow.find("td:eq(0)").html("&lt;select class='easyui-combobox' name='cFirmGuid" + rowNum + "' style='width:100%;'&gt;&lt;/select&gt;"); $newRow.find("input:eq(0)").attr("name", "cContactAdd" + rowNum); $newRow.find("input:eq(1)").attr("name", "cIllegality" + rowNum); $newRow.find("input:eq(2)").attr("name", "iIssueNum" + rowNum); $newRow.find("input:eq(3)").attr("name", "cSituation" + rowNum); $("#JDJLK").before($newRow); $newRow.find(".easyui-combobox").combobox(&#123; valueField: 'cEnterpriseGUID', textField: 'cEnterpriseName', data: res, onChange: function (newValue, oldValue) &#123; //获得企业地址 changeEnterprise(newValue, rowNum);//修改下拉框值后，触发事件 &#125; &#125;); &#125; 2、HTML代码12345678910111213141516171819202122&lt;table&gt;&lt;tr class="firmRow hideFirmRow"&gt; &lt;td colspan="2"&gt; &lt;select class="easyui-combobox" style="width:100%;"&gt; &lt;/select&gt; &lt;/td&gt; &lt;td colspan="2"&gt; &lt;asp:TextBox runat="server" /&gt; &lt;/td&gt; &lt;td colspan="4"&gt; &lt;asp:TextBox runat="server" /&gt; &lt;/td&gt; &lt;td&gt; &lt;asp:TextBox runat="server" onkeyup="if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,'')&#125;else&#123;this.value=this.value.replace(/\D/g,'')&#125;" onafterpaste="if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,'')&#125;else&#123;this.value=this.value.replace(/\D/g,'')&#125;" /&gt; &lt;/td&gt; &lt;td colspan="3"&gt; &lt;asp:TextBox runat="server" /&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 3、firmRow表示是第一行，hideFirmRow用来将第一行隐藏当需要创建行时，直接使用jquery的Clone，将firmRow克隆然后设置值就好了，方便操作。1var $newRow = $(&quot;.firmRow:first&quot;).clone(); 4、其中文本控件增加了JS验证，只能输入数字12&lt;asp:TextBox runat=&quot;server&quot; onkeyup=&quot;if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,&apos;&apos;)&#125;else&#123;this.value=this.value.replace(/\D/g,&apos;&apos;)&#125;&quot;onafterpaste=&quot;if(this.value.length==1)&#123;this.value=this.value.replace(/[^1-9]/g,&apos;&apos;)&#125;else&#123;this.value=this.value.replace(/\D/g,&apos;&apos;)&#125;&quot; /&gt; 5、easyui-combobox 绑定初始化12345 $(&quot;.easyui-combobox&quot;).combobox(&#123;valueField: &apos;值列名&apos;,textField: &apos;文本列名&apos;,data: res //res是JSON对象 &#125;);]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>easyui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.Net 文件上传大小限制]]></title>
    <url>%2F2016%2F11%2F15%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、主要有两个地方需要配置，httpRuntime节点 maxRequestLength 最大请求长度 byterequestLimits节点 maxAllowedContentLength 最大上传文件长度 byte这两个值需要设置为一致，IIS7 最大支持2GB 即2147483647B 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;connectionStrings configSource="XmlConfig\database.config" /&gt; &lt;appSettings configSource="XmlConfig\system.config" /&gt; &lt;system.web&gt; &lt;!-- 文件上传 允许请求的最大长度 单位byte 默认4096KB--&gt; &lt;httpRuntime requestValidationMode="2.0" requestLengthDiskThreshold="256" maxRequestLength="2147483647" executionTimeout="1800"/&gt; &lt;/system.web&gt; &lt;system.webServer&gt; &lt;modules runAllManagedModulesForAllRequests="true" /&gt; &lt;security&gt; &lt;requestFiltering&gt; &lt;!--上传文件大小限制单位字节 byte 最大不超过2G--&gt; &lt;requestLimits maxQueryString="2147483647" maxAllowedContentLength="2147483647"/&gt; &lt;/requestFiltering&gt; &lt;/security&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>ASP.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FireFox右键菜单兼容]]></title>
    <url>%2F2016%2F10%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Firefox Event与 IE window Event兼容 在系统开发中，需要用户操作鼠标右键打开菜单时，IE直接通过使用window.event来获得对象的事件而火狐浏览器则使用触发方法中的event来获得，为了同时兼容，最后需要标准化事件对象。即：var evt=evt || event123456789101112131415&lt;script&gt; $(function()&#123; $(element).bind("contextmenu", function (evt) &#123; //设置弹出框对象高度宽度 //获取的这个ID为obj的DIV对象就是个实例引起鼠标事件的元素 //evt代表事件对象（W3C DOM标准下） var evt=evt || event; //标准化事件对象（W3C DOM 和IE DOM ） evt.Target=evt.Target || evt.srcElement;//标准化事件对象属性&lt;引起事件的元素&gt; //（W3C DOM 和IE DOM ） evt.layerX=evt.layerX || evt.offsetX;//鼠标相对于引起事件的元素的父元素的X坐标(标准化IE) evt.layerY=evt.layerY || evt.offsetY;//鼠标相对于引起事件的元素的父元素的Y坐标(标准化IE) alert("相对这个DIV的X方向的坐标"+evt.layerX+"\n相对这个DIV的Y方向的坐标"+evt.layerY) &#125; &#125;);&lt;/script&gt; 123456789101112131415//自定义右键菜单 jQuery(tabControl_tab_ul).bind("contextmenu", function (e) &#123; var event = e || window.event;//e表示火狐事件，window.event表示chrome或IE事件 var oMenu = jQuery('.rightMenu');//右键要显示的菜单 oMenu.show(); oMenu.css('top', event.clientY + "px"); oMenu.css('left', event.clientX + "px"); window.setTimeout(function () &#123; oMenu.hide();//延时2秒后自动关闭 &#125;, 10000); return false; &#125;).bind("click", function () &#123; oMenu.hide();//单击后关闭 &#125;);]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZIP压缩.Net与Android相互解压]]></title>
    <url>%2F2016%2F09%2F28%2FZIP%E5%8E%8B%E7%BC%A9-Net%E4%B8%8EAndroid%E7%9B%B8%E4%BA%92%E8%A7%A3%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[使用.NET搭建webservice，使用JAVA在Android端接受 .Net与JAVA互相通过ZIP压缩协议进行压缩和解压字符串，减少传输字节量，加快传输速度增加用户友好。Android123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.example.administrator.myapplication;import android.util.Base64;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * Created by Administrator on 2016/9/15. */public class GZIP &#123; public static byte[] compress(String string) throws IOException &#123; ByteArrayOutputStream os = new ByteArrayOutputStream(string.length()); GZIPOutputStream gos = new GZIPOutputStream(os); gos.write(string.getBytes()); gos.close(); byte[] compressed = os.toByteArray(); os.close(); return compressed; &#125; public static String decompress(byte[] compressed) throws IOException &#123; final int BUFFER_SIZE = 32; ByteArrayInputStream is = new ByteArrayInputStream(compressed); GZIPInputStream gis = new GZIPInputStream(is, BUFFER_SIZE); StringBuilder string = new StringBuilder(); byte[] data = new byte[BUFFER_SIZE]; int bytesRead; while ((bytesRead = gis.read(data)) != -1) &#123; string.append(new String(data, 0, bytesRead)); &#125; gis.close(); is.close(); return string.toString(); &#125; public static String compress1(String str) throws IOException &#123; byte[] data=str.getBytes("UTF-8"); byte[] blockcopy = ByteBuffer .allocate(4) .order(java.nio.ByteOrder.LITTLE_ENDIAN) .putInt(data.length) .array(); ByteArrayOutputStream os = new ByteArrayOutputStream(data.length);// os.write(new byte[]&#123;0x05, 0, 0, 0&#125;,0,4); GZIPOutputStream gos = new GZIPOutputStream(os); gos.write(data); gos.close(); os.close(); byte[] compressed = new byte[4 + os.toByteArray().length]; System.arraycopy(blockcopy, 0, compressed, 0, 4); System.arraycopy(os.toByteArray(), 0, compressed, 4, os.toByteArray().length); byte[] result1= Base64.encode(compressed,Base64.DEFAULT); return new String (result1); &#125; public static String decompress1(String zipText) throws IOException &#123; byte[] compressed = Base64.decode(zipText,Base64.DEFAULT); if (compressed.length &gt; 4) &#123; GZIPInputStream gzipInputStream = new GZIPInputStream( new ByteArrayInputStream(compressed, 4, compressed.length - 4)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); for (int value = 0; value != -1;) &#123; value = gzipInputStream.read(); if (value != -1) &#123; baos.write(value); &#125; &#125; gzipInputStream.close(); baos.close(); String sReturn = new String(baos.toByteArray(), "UTF-8"); return sReturn; &#125; else &#123; return ""; &#125; &#125;&#125; .Net12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;using System.IO.Compression;using System.Text;namespace GZIPService&#123; public class ZipHelper &#123; public static string compress(string text) &#123; byte[] buffer = Encoding.UTF8.GetBytes(text); MemoryStream ms = new MemoryStream(); using (GZipStream zip = new GZipStream(ms, CompressionMode.Compress, true)) &#123; zip.Write(buffer, 0, buffer.Length); &#125; ms.Position = 0; MemoryStream outStream = new MemoryStream(); byte[] compressed = new byte[ms.Length]; ms.Read(compressed, 0, compressed.Length); byte[] gzBuffer = new byte[compressed.Length + 4]; System.Buffer.BlockCopy(compressed, 0, gzBuffer, 4, compressed.Length); System.Buffer.BlockCopy(BitConverter.GetBytes(buffer.Length), 0, gzBuffer, 0, 4); return Convert.ToBase64String(gzBuffer); &#125; public static string decompress(string compressedText) &#123; byte[] gzBuffer = Convert.FromBase64String(compressedText); using (MemoryStream ms = new MemoryStream()) &#123; int msgLength = BitConverter.ToInt32(gzBuffer, 0); ms.Write(gzBuffer, 4, gzBuffer.Length - 4); byte[] buffer = new byte[msgLength]; ms.Position = 0; using (GZipStream zip = new GZipStream(ms, CompressionMode.Decompress)) &#123; zip.Read(buffer, 0, buffer.Length); &#125; return Encoding.UTF8.GetString(buffer); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c#基础-扩展方法]]></title>
    <url>%2F2016%2F09%2F12%2Fc-%E5%9F%BA%E7%A1%80-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[扩展方法的讲解C#扩展方法，爱你在心口难开转自无风听海 什么是扩展方法?好几天了打算记录一下，今天我们来深入研究一下，探究一下扩展方法的实现机制；那么到底什么是扩展方法呢？扩展方法使您能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。扩展方法是一种特殊的静态方法，但可以像扩展类型上的实例方法一样进行调用。对于用 C# 和 Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中实际定义的方法之间没有明显的差异。也许你并不明白以上的意思，那一点都没有关系，如果我们平时一定经常使用linq标准查询，那么我们就一直在使用扩展方法啦！微软为枚举的集合扩展了很多的标准查询方法，极大的方便了我们的使用！请看下面的例子没有使用扩展方法 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Text;using wuFengTingHai.Person;namespace ExtendMethod&#123; public class LinqExtend &#123; private IList&lt;Person&gt; persons = new List&lt;Person&gt;(); public IList&lt;Person&gt; Persons &#123; get &#123; //删除集合中名称为无风听海的记录，没有引入system.linq,所以不能使用扩展方法 foreach(Person person in this.persons) &#123; if (person.Name.Equals("无风听海")) &#123; this.persons.Remove(person); &#125; &#125; return this.persons; &#125; set &#123; this.persons = value; &#125; &#125; &#125; &#125; 使用扩展方法 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person.Extend&#123; public class LinqExtend &#123; private IList&lt;Person&gt; persons = new List&lt;Person&gt;(); public IList&lt;Person&gt; Persons &#123; get &#123; //删除集合中名称为无风听海的记录，引入system.linq的扩展方法 this.persons = this.persons.Where(m =&gt; !m.Name.Equals("无风听海")).ToList&lt;Person&gt;(); return this.persons; &#125; set &#123; this.persons = value; &#125; &#125; &#125;&#125; 引入system.linq后,扩展方法的智能提示 从上面的例子中我们可以学到扩展方法的使用方法。那么扩展方法是怎么定义的呢？查看一下Where扩展方法的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #region Assembly System.Core.dll, v2.0.50727// C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.5\System.Core.dll#endregionusing System;using System.Collections;using System.Collections.Generic;using System.Runtime.CompilerServices;namespace System.Linq&#123; //为了方便展示，将其他的扩展方法进行了删除精简 public static class Enumerable &#123; public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate); public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate); &#125;&#125;``` 虽然扩展方法通过实例方法语法进行调用的，但是他们却被定义为静态方法。从定义中我们可以看到，它们的第一个参数指定该方法作用于哪个类型，并且该参数以 this 修饰符为前缀。 下面我们自己定义一个Person类和PersonExtend类来扩展方法，来看看编译器究竟做了什么！```Cusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person&#123; public class Person &#123; public Person(string name,string sex,string age) &#123; this.name = name; this.sex = sex; this.age = age; &#125; private string name; public string Name &#123; set &#123; this.name = value; &#125; get &#123; return this.name; &#125; &#125; private string sex; public string Sex &#123; set &#123; this.sex = value; &#125; get &#123; return this.sex; &#125; &#125; private string age; public string Age &#123; set &#123; this.age = value; &#125; get &#123; return this.age; &#125; &#125; public override string ToString() &#123; return string.Format("&#123;0&#125;","类本身的方法覆盖了同名扩展方法"); &#125; &#125;&#125; PersonExtend，对Person类进行方法扩展 12345678910111213141516using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person.Extend&#123; public static class PersonExtend &#123; public static string GetDescription(this Person person,string msg) &#123; return string.Format("&#123;0&#125; 我是&#123;1&#125;,性别&#123;2&#125;,今年&#123;3&#125;岁",msg,person.Name,person.Sex,person.Age); &#125; &#125;&#125; 客户端调用结果 让我们看一下客户端main方法的IL代码，我们就知道编译器到底干什么了！ 1234567891011121314151617181920212223242526272829303132333435 .method private hidebysig static void Main(string[] args) cil managed&#123; .entrypoint // Code size 63 (0x3f) .maxstack 4 .locals init ([0] class [wuFengTingHai.Person]wuFengTingHai.Person.Person person) IL_0000: nop IL_0001: ldstr bytearray (E0 65 CE 98 2C 54 77 6D ) // .e..,Twm IL_0006: ldstr bytearray (37 75 ) // 7u IL_000b: ldstr "20" IL_0010: newobj instance void [wuFengTingHai.Person]wuFengTingHai.Person.Person::.ctor(string, string, string) IL_0015: stloc.0 IL_0016: ldloc.0 IL_0017: ldstr bytearray (F4 76 A5 63 1A 90 C7 8F 59 97 01 60 7B 7C 50 00 // .v.c....Y..`&#123;|P. 65 00 72 00 73 00 6F 00 6E 00 45 00 78 00 74 00 // e.r.s.o.n.E.x.t. 65 00 6E 00 64 00 03 8C 28 75 2C 00 ) // e.n.d...(u,. //直接使用静态类PersonExtend调用 IL_001c: call string [wuFengTingHai.Person.Extend]wuFengTingHai.Person.Extend.PersonExtend::GetDescription(class [wuFengTingHai.Person]wuFengTingHai.Person.Person, string) IL_0021: call void [mscorlib]System.Console::WriteLine(string) IL_0026: nop IL_0027: ldloc.0 IL_0028: ldstr bytearray (F4 76 A5 63 1A 90 C7 8F 50 00 65 00 72 00 73 00 // .v.c....P.e.r.s. 6F 00 6E 00 84 76 9E 5B 8B 4F 03 8C 28 75 2C 00 ) // o.n..v.[.O..(u,. //直接使用Person的扩展方法调用 IL_002d: call string [wuFengTingHai.Person.Extend]wuFengTingHai.Person.Extend.PersonExtend::GetDescription(class [wuFengTingHai.Person]wuFengTingHai.Person.Person, string) IL_0032: call void [mscorlib]System.Console::WriteLine(string) IL_0037: nop IL_0038: call string [mscorlib]System.Console::ReadLine() IL_003d: pop IL_003e: ret&#125; // end of method Program::Main 从IL中我们可以看到扩展方法与其扩展的类之间并没有什么本质的联系，只是编译器跟我们玩的把戏罢了，最终编译器还是将扩展方法转化成静态类的静态方法调用，所以扩展方法不能访问相应类的私有字段和私有方法；至于为什么使用静态类的静态方法，我考虑可能是这样效率相对较高，同时扩展方法作为其他类的扩展，本身类的实例化没有什么意义； 如果扩展方法和被扩展类中的方法相同，会怎么样？ 123456789101112131415161718192021using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace wuFengTingHai.Person.Extend&#123; public static class PersonExtend &#123; public static string GetDescription(this Person person,string msg) &#123; return string.Format("&#123;0&#125; 我是&#123;1&#125;,性别&#123;2&#125;,今年&#123;3&#125;岁",msg,person.Name,person.Sex,person.Age); &#125; public static string ToString(this Person person) &#123; return "扩展方法能够覆盖原始类的同名方法"; &#125; &#125;&#125; 客户端调用代码 123456789101112131415161718192021using System;using System.Collections.Generic;using System.Linq;using System.Text;using wuFengTingHai.Person.Extend;namespace ExtendMethod&#123; class Program &#123; static void Main(string[] args) &#123; wuFengTingHai.Person.Person person = new wuFengTingHai.Person.Person("无风听海", "男", "20"); //Console.WriteLine(wuFengTingHai.Person.Extend.PersonExtend.GetDescription(person, "直接通过静态类PersonExtend调用,")); //Console.WriteLine(person.GetDescription("直接通过Person的实例调用,")); Console.WriteLine(person.ToString()); Console.ReadLine(); &#125; &#125;&#125; 调用结果 以上我们可以看到编译时，扩展方法的优先级总是比类型本身中定义的实例方法低，所以与接口或类方法具有相同名称和签名的扩展方法永远不会被调用。 综上进行总结 扩展方法不改变被扩展类的代码，不用重新编译、修改、派生被扩展类 扩展方法不能访问被扩展类的私有成员 扩展方法会被被扩展类的同名方法覆盖，所以实现扩展方法我们需要承担随时被覆盖的风险 扩展方法看似实现了面向对象中扩展对修改说不的特性，但是也违背了面向对象的继承原则，被扩展类的派生类是不能继承扩展扩展方法的，从而又违背了面向对象的多态性。 在我们稳定的引用同一个版本的类库，但是我们没有该类库的源代码，那么我们可以使用扩展方法；但是从项目的可扩展、可维护和版本控制方面来说，都不建议 使用扩展方法进行类的扩展。]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>扩展方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图常用功能的使用]]></title>
    <url>%2F2016%2F09%2F10%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[百度地图API使用 资料1.JavaScript API2.demo3.工具开源库（如鼠标点击后计算范围、聚合效果等） 常用的功能及实现引入资源包引入常用的资源包（引入http://api.map.baidu.com/api?v=2.0&amp;ak=tzAcIFZ5xCoRwm63NcBGfoVB 时ak是自己申请的一个秘钥）1234567891011121314&lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;!--jquery--&gt; &lt;!--百度地图--&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=tzAcIFZ5xCoRwm63NcBGfoVB"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.css" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/SearchInfoWindow/1.5/src/SearchInfoWindow_min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="http://api.map.baidu.com/library/SearchInfoWindow/1.5/src/SearchInfoWindow_min.css" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/AreaRestriction/1.2/src/AreaRestriction_min.js"&gt;&lt;/script&gt; &lt;!--聚合--&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/TextIconOverlay/1.2/src/TextIconOverlay_min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer.js"&gt;&lt;/script&gt; &lt;!--聚合--&gt; &lt;!--百度地图--&gt; 初始化地图1$(function()&#123; /*所有js代码放入*/&#125;); 设置中心点创建地图对象设置中心点以及缩放的级别zoom123456789// 百度地图API功能 var map = new BMap.Map("allmap"); // 创建Map实例 /*centerAndZoom(center:Point, zoom:Number) none 设初始化地图。 &lt;span style="color:#ff0000;"&gt; 如果center类型为Point时，zoom必须赋值，范围3-19级，&lt;/span&gt;若调用高清底图（针对移动端开发）时， zoom可赋值范围为3-18级。如果&lt;span style="color:#ff0000;"&gt;center类型为字符串时，比如“北京”，zoom可以忽略&lt;/span&gt;，地图将自动根据center适配最佳zoom级别。 */ //map.centerAndZoom(new BMap.Point(113.195425, 39.657158), 10); //初始化地图,设置中心点坐标和地图级别 map.centerAndZoom("北京市"); &#125;); 插入缩放定位等控件12345678910 var navigationControl = new BMap.NavigationControl(&#123;// 靠左上角位置anchor: BMAP_ANCHOR_TOP_LEFT,// LARGE类型type: BMAP_NAVIGATION_CONTROL_LARGE,// 启用显示定位enableGeolocation: true,showZoomInfo: true, &#125;); map.addControl(navigationControl); 开启滚轮缩放及禁用双击放大12map.enableScrollWheelZoom(); //开启鼠标滚轮缩放map.disableDoubleClickZoom(true);//禁用双击放大。 限制地图显示区域超出显示区域自动修改回限制区域，参数需要两个点的坐标，即限制区域地图的左上角和右下角坐标1234567//限制区域 var b = new BMap.Bounds(new BMap.Point(111.822527, 40.296748), new BMap.Point(114.566024,39.043834)); try &#123; BMapLib.AreaRestriction.setBounds(map, b); &#125; catch (e) &#123; alert(e); &#125; 添加行政区域（县、区级别）123456789101112131415161718function getBoundary() &#123; var bdary = new BMap.Boundary(); bdary.get("西安市雁塔区", function (rs) &#123; //获取行政区域 map.clearOverlays(); //清除地图覆盖物 var count = rs.boundaries.length; //行政区域的点有多少个 if (count === 0) &#123; alert('未能获取当前输入行政区域'); return; &#125; var pointArray = []; for (var i = 0; i &lt; count; i++) &#123; var ply = new BMap.Polygon(rs.boundaries[i], &#123; strokeWeight: 2, strokeColor: "#ff0000" &#125;); //建立多边形覆盖物 map.addOverlay(ply); //添加覆盖物 pointArray = pointArray.concat(ply.getPath()); &#125; map.setViewport(pointArray); //调整视野 &#125;); &#125; 结合后台获得制定区域并画出1234567891011121314151617181920ShowArea(); //读取已有区域 function ShowArea() &#123; $.post("Handler.ashx?action=getAreaData", "", function (data, status) &#123; //var data = eval(dataJSON); var points = GetPointsArray(data); var polygon1 = new BMap.Polygon(points, &#123; strokeColor: "blue", fillColor: "#f0979f", strokeWeight: 2, strokeOpacity: 0.5, fillOpacity: 0.3 &#125;); //创建多边形 map.addOverlay(polygon1); //增加多边形 &#125;); &#125; function GetPointsArray(points) &#123; var pointsArray = points.split(";"); var result = new Array(); for (var i = 0; i &lt; pointsArray.length; i++) &#123; result[i] = new BMap.Point(pointsArray[i].split(",")[0], pointsArray[i].split(",")[1]); &#125; return result; &#125; 后台获得区域（点的集合）使用ajax与一般处理程序1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace WebApplication3&#123; /// &lt;summary&gt; /// Handler 的摘要说明 /// &lt;/summary&gt; public class Handler : IHttpHandler &#123; public void ProcessRequest(HttpContext context) &#123; string action=context.Request["action"]; switch(action) &#123; case "getAreaData": GetAreaData(context); break; &#125; &#125; public void GetAreaData(HttpContext context) &#123; string s = "108.860872, 34.258506;108.831975, 34.258587;108.827325, 34.254061;108.82198, 34.253861;108.821721, 34.242147;108.82502, 34.242241;108.825366, 34.235732;108.828081, 34.235904;108.828549, 34.225515;108.841104, 34.22704;108.836877, 34.210519;108.839338, 34.205291;108.852262, 34.206639;108.852829, 34.18584;108.875588, 34.185636;108.875624, 34.177398;108.980798, 34.177959;109.00823, 34.180186;109.022781, 34.185512;109.039102, 34.182088;109.060345, 34.191182;109.053019, 34.212803;109.056843, 34.243072;109.054189, 34.257263;109.033871, 34.257004;109.036981, 34.256214;109.037215, 34.240337;109.027373, 34.240809;109.027372, 34.243714;109.022632, 34.243735;109.02261, 34.248791;109.002924, 34.248887;108.971729, 34.236415;108.938526, 34.235527;108.897292, 34.253332;108.89572, 34.257881;108.860872, 34.258506"; context.Response.Write(s); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125;&#125; 点聚合及批量弹出窗口12345678910111213141516171819202122232425262728293031323334353637383940414243// 百度地图API功能 var map = new BMap.Map("allmap"); map.centerAndZoom(new BMap.Point(116.404, 39.915), 4); map.enableScrollWheelZoom(); var MAX = 10; var markers = []; var pt = null; var i = 0; for (; i &lt; MAX; i++) &#123; pt = new BMap.Point(Math.random() * 40 + 85, Math.random() * 30 + 21); var marker = new BMap.Marker(pt); markers.push(marker); var content1 = '&lt;div style="margin:0;line-height:20px;padding:2px;"&gt;内容&lt;/div&gt;'; markers.push(marker); &lt;span style="color:#ff0000;"&gt; //使用闭包 这样内容才能显示的不同，否则全部都会只显示最后一个content1的内容&lt;/span&gt; (function (content1) &#123; marker.addEventListener("click", function (e) &#123; //创建检索信息窗口对象 var searchInfoWindow = null; searchInfoWindow = new BMapLib.SearchInfoWindow(map, content1, &#123; title: '信息&lt;a target="_top" onclick="alert(1)" style="margin-left:5px;font-size:12px;line-height:30px;color:#3d6dcc;font-weight:normal;text-decoration:none;cursor:pointer;"&gt;详情»&lt;/a&gt;', //标题 width: 250, //宽度 height: 200, //高度 panel: "panel", //检索结果面板 enableAutoPan: true, //自动平移 enableSendToPhone: false,//百度发送短信图标 searchTypes: [ //BMAPLIB_TAB_SEARCH, //周边检索 //BMAPLIB_TAB_TO_HERE, //到这里去 //BMAPLIB_TAB_FROM_HERE //从这里出发 ] &#125;); searchInfoWindow.open(e.target); &#125;); &#125;)(content1) &#125; //最简单的用法，生成一个marker数组，然后调用markerClusterer类即可。 var markerClusterer = new BMapLib.MarkerClusterer(map, &#123; markers: markers &#125;);]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>百度地图</tag>
        <tag>地图操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4Net生成空日志文件的解决方法]]></title>
    <url>%2F2016%2F09%2F10%2FLog4Net%E7%94%9F%E6%88%90%E7%A9%BA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[设置Log4Net并自动删除空日志1、根据网上的配置说明，该配置将记录Error 级别的错误，按照月份分文件夹，按照天来分文件进行日志的记录，完成了配置如下：123456789101112131415161718192021222324252627282930313233&lt;configuration&gt; &lt;configSections&gt; &lt;section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net, Version=1.2.11.0, Culture=neutral, PublicKeyToken=1B44E1D426115821" /&gt; &lt;/configSections&gt; &lt;log4net&gt; &lt;root&gt; &lt;!--&lt;level value="DEBUG"/&gt;--&gt; &lt;level value="ERROR"/&gt; &lt;!--根据log级别记录到不同的日志文件--&gt; &lt;!--&lt;appender-ref ref="DebugLog" /&gt;--&gt; &lt;appender-ref ref="ErrorLog" /&gt; &lt;/root&gt; &lt;appender name="ErrorLog" type="log4net.Appender.RollingFileAppender"&gt; &lt;!-- 最后放开注释--&gt; &lt;!--&lt;lockingModel type="命名空间.MinimalLockDeleteEmpty" /&gt;--&gt; &lt;param name="File" value="Log\" /&gt; &lt;param name="AppendToFile" value="true" /&gt; &lt;param name="RollingStyle" value="Date" /&gt; &lt;param name="DatePattern" value="yyyy-MM\\yyyy-MM-dd.'log'" /&gt; &lt;param name="StaticLogFileName" value="false" /&gt; &lt;layout type="log4net.Layout.PatternLayout"&gt; &lt;conversionPattern value="%date [%thread] %-5level %logger - %message%newline" /&gt; &lt;/layout&gt; &lt;securityContext type="log4net.Util.WindowsSecurityContext"&gt; &lt;credentials value="Process" /&gt; &lt;/securityContext&gt; &lt;filter type="log4net.Filter.LevelRangeFilter"&gt; &lt;levelMin value="ERROR" /&gt; &lt;levelMax value="ERROR" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;/log4net&gt;&lt;/configuration&gt; 2、运行上面的（除红色）的设置后，发现就算没有抛出异常，log4net每天同样会创建一个空的日志文件。3、查找搜索了下国内网站，未发现解决的方法，只是想到如果log4net不支持的化，可以在网站运行后创建一个定时器，每隔一天检查一下对应的日志文件是否有空，有则删除；4、google搜索到国外的网站，发现可以继承FileAppender.MinimalLock类 重写ReleaseLock 方法 来实现写日志完成后检查空文件并删除的功能。引用地址1234567891011121314151617181920212223using log4net.Appender;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;namespace 命名空间&#123; public class MinimalLockDeleteEmpty : FileAppender.MinimalLock &#123; public override void ReleaseLock() &#123; base.ReleaseLock(); var logFile = new FileInfo(CurrentAppender.File); if (logFile.Exists &amp;&amp; logFile.Length &lt;= 0) &#123; logFile.Delete(); &#125; &#125; &#125;&#125; 5、最后在配置文件中将类插入完成调用1&lt;lockingModel type="命名空间.MinimalLockDeleteEmpty" /&gt; 6、最后Log4Net效果就是记录中没有空日志文件且存放服务器时按照月份建文件夹，文件夹内按照日期建日志文件。]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Log4Net</tag>
        <tag>ASP.NET日志</tag>
        <tag>空日志删除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>